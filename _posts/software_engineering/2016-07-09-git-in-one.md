---
layout: post
title: git原理与实践
description: ""
category: 软件工程
tags: [git]
---
{% include JB/setup %}

* toc
{:toc}

<hr />


跳过了assume-unchanged等三个命令，记得补上。



本文是对git主要知识点的梳理，主要依循[git book][0]以及[git reference][1]而来，亦可以看做是该书的读书笔记。
所有用图如无另行说明，都来自该书网页版配图。

本文与原书的顺序略不同，先从git内部结构讲起，然后分析一些常用操作对内部结构的影响，
如此能深刻的理解当我们使用git的时候，到底发生了什么。

在深入理解git原理的基础上，我们在列举一些常用、难用操作、坏实践以及最佳实践，就能知其所以然了。

最后提一下git协作模型。

# 内部原理
## 内部基本结构

一个git仓库的结构可以形容为“一个.git目录、两类指针文件、三个区、四种对象”。

一个`.git`目录指的是一个仓库内所有与版本管理、版本历史相关的内容都存在`.git`目录下。

### 三个区

GIT设计有三个区：工作区、暂存区、仓库区。这三个区分别代表文件管理的三个阶段。
仓库区里的文件都是版本历史。工作区是用户可以任意修改的地方，而暂存区是准备提交到仓库区的工作区备份。

在实际存储上，工作区的文件存储在.git所在的目录下（不包括.git目录下的内容），就是我们的文件系统。

仓库区的文件存储在`.git/objects`中。

暂存区的文件也存储在`.git/objects`中，但索引在`.git/index`中。

后面我们会验证上面所说的存储位置。

工作区又称Working Tree或Working Directory。

暂存区又称之为Stage或Index或cache。

仓库区又称之为store或objects。


文件未进入暂存区，称之为“未跟踪(untracked)”，否则称之为“已跟踪”。

文件未进入暂存区，是因为merge过程中存在冲突，而不是因为未执行Add。冲突的文件未能完成merge，因而也称为unmerged文件。

需要注意的是，三个区并非对称的。git作为版本管理系统，所管理内容通常有多个分支，工作区与暂存区是多个版本共用的，或者更确切的说--独占使用。
这个特性会导致到checkout分支切换以及stash时候出一点小问题，后面具体命令时，我们再讲。

### 四种对象

所谓四种是指文件对象、树对象、提交对象、标签对象。这四类对象都存储在`.git/objects`目录下。

文件对象与树对象可看做是文件与文件夹在版本管理下的对应的东西。提交对象用来表示一次提交，提交对象永远执行一个树对象。
标签对象则用来对任意其他git对象打标签。因此提交对象与标签对象都会一种“指针对象”。我们知道，对象之所以成为一个对象，是因为要封装一些自己独有的信息。提交对象要封装提交说明（comment），标签对象也一样，要封装附加注释。

下面分别讲各类对象的本质以及git提供的相关操作命令。但在开始之前，先让我们看看如何查看objects中的对象。

#### 查看对象

查看对象使用`git cat-file`，详细参考"命令要点"小节。

列出当前git仓库的所有对象，可以使用`git cat-file --batch-check --batch-all-objects`，后面我们会用到这一点。

`cat-file`可以对四类对象中任意对象使用。

但是对于树对象，其有自己的格式, 用`cat-file`虽然也能读取，但是会出现乱码。最好用`ls-tree`。

注意区分于命令`read-tree`，该命令与`write-tree`一起是用于暂存区与仓库区版本历史之间读写的。

<hr />

#### 文件对象

[git book][3]讲的很明白，文件对象是由一个简单的文件头加文件内容组成，其格式如下：

```
TYPE LENGTH \0 CONTENT

\0是空字节。
```

然后再对上面用sha1算法求散列值（如果是中文等非ascii字符则会先转码为utf-8）作为key。

最后通过zlib压缩存到objects下以散列值为名的一个文件中。注意**散列值是用压缩前的内容求出的**。

从上面过程可以看错，文件对象的创建与文件名是没有任何关系的。实际上在git中，不同的文件名但文件内容相同的情况下，只会创建一个文件对象，因为作为key的hash值是相同的。

在git中，创建文件对象可以用命令`git hash-object -w`来完成，`-w`表示写文件到objects目录，否则只求hash值，有关该命令的细节参考“命令要点”节。

那一个文件对象存储到objects中后，还会被修改吗？会被删除吗？答案是不会被修改，但可能在`git gc`过程中被删除。

<hr />

#### 树对象

一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。
例如，某项目当前对应的最新树对象可能是这样的：

```brush:bash
$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
```

`master^{tree}` 语法表示 master 分支上最新的提交所指向的树对象。 

**创建树对象**

创建树对象，不能再用`hash-object`。

	通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象， 如此重复便可依次记录（某个时间段内）一系列的树对象。 因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。 

上面引自git book。可以看到树对象是根据在暂存区(index区)来的，而暂存区存放了整个目录树的一个快照（注意只有目录树，文件对象已经创建到objects中去了）。

	实际上文件从工作区加入到暂存区的时候，其对应的文件对象已经创建到objects中了，但是没有创建相应的树对象与提交对象。
	由此可知`git add -A`比如是一个很耗时的动作。问题是，这时候放弃暂存区的内容，然后删掉文件，对应的objects显然没有记录到版本中，
	那这个objects会被删掉吗？什么时候删掉？？？？？？？？？？？？？？？？？？？？？？

下面我们分析树对象的特性会知道，树对象是根据其下文件与文件夹名字与hash值来创建的，因而创建顶层树对象必然递归创建到子目录。因此树对象
没办法一个个创建，要创建必然涉及到其下面的子目录对应的树对象的创建，除非该目录没有子目录。

另外，使用`git add`添加目录，其实是添加的下面的文件到objects文件对象。因此`git add`没法添加空目录。一些宣称git能添加空目录的资料无外乎在
空目录下再创建一个文件，有够扯淡，能创建文件还叫什么空目录。

上面是树对象创建的基本原理，下面我们来看具体git命令。


首先，要创建树对象，必须要创建暂存区index区，可以通过底层命令 `git update-index` 为一个单独文件创建一个暂存区。

这个命令能够创建文件夹对应的暂存区吗？是递归创建的吗？


**树对象特性**

树对象其实不应该叫树对象，而应该叫做树节点对象，因为一个树对象仅仅是非递归地对应一个目录，而不是对应整个目录树。

很容易验证这一点。用`git init`新建一个空的git仓库，然后创建如下的目录结构：

```
.git
dir1
	-- data11.txt
	-- data12.txt
	dir2
		-- data21.txt
		-- data22.txt
```

各个txt的文件内容是空的，提交后我们来查看下objects中创建的对象：
```brush:bash

# git cat-file --batch-check --batch-all-objects
3678495e526a955e4f56b0f9ce2f2185a004412c tree 31
3775f81b76bd3d6a986114e4a7ab19c79cc0b096 tree 76
a980596539156d1b037c29e1b883b82140759336 tree 107
b755d8f8679a1e6d452b6238ed7f94ad10fb5690 commit 163
e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 blob 0

```

可以看到创建了3个树对象，让我们看下他们的内容：
```brush:bash

# git ls-tree 3678495e526a955e4f56b0f9ce2f2185a004412c
040000 tree a980596539156d1b037c29e1b883b82140759336    dir1

# git ls-tree a980596539156d1b037c29e1b883b82140759336
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    data11.txt
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    data12.txt
040000 tree 3775f81b76bd3d6a986114e4a7ab19c79cc0b096    dir2

# git ls-tree 3775f81b76bd3d6a986114e4a7ab19c79cc0b096
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    data21.txt
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    data22.txt

```

可以看到，这三个目录分别是.git所在仓库顶级目录内容、dir1目录内容、dir2目录内容。

因此每个树对象实际上仅仅非递归地存了一个目录下的文件夹与文件列表而已。因此，树对象叫树节点对象或许更合适一些。


让我们在dir2下data21.txt中添加一行内容`hello git`，提交后然后再查看所有objects:

```brush:bash
# git cat-file --batch-check --batch-all-objects
3678495e526a955e4f56b0f9ce2f2185a004412c tree 31
3775f81b76bd3d6a986114e4a7ab19c79cc0b096 tree 76
5fd29b4a7c95c2153f446bf7b984d0f78778bc24 commit 220
818324276399b67c0dd91cc14f0759cf0006c876 tree 107
a980596539156d1b037c29e1b883b82140759336 tree 107
b755d8f8679a1e6d452b6238ed7f94ad10fb5690 commit 163
e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 blob 0
ebc1c1b8004c144bb124f7fe39e06e15b502288b tree 31
f09e9c379f5fe8f4ce718641c356df87906d87a6 blob 9
f1465bf4ab5c9d15e2991bf62e5758e602f21aaf tree 76
```

用`ls-tree`检查可以发现三个目录对应的树对象都重新建立了，并且多了一个文件对象（data21.txt有了新版本）与一个提交对象。


我们可以删掉.git目录，还原成最开始的目录样子进一步实验。可以发现无论是更改data21.txt内容还是改变data21.txt名字，或者在dir2下新添加data23.txt。都会导致dir2对应的树对象重建。

然后递归地导致dir1树对象重建，直至顶级目录重建。

但是如果我们修改dir2的名字为dir3，则dir2对应的树对象不会重建，但是dir1与顶级目录对应的树对象会重建一个版本。

由此我们我们可以推断出git的树对象是根据其对应目录下所有文件的名字与其sha1值来判断是否有建立新版本的，而跟其本身的名字没关系。
这一点文件与目录是一致的，是否建立新版本根据其内容来而不是根据其名字来，名字变更属于其所在目录对应的树对象变更。

<hr />

#### 提交对象

创建一个提交对象需要提供一个当前版本的树对象以及一个父提交对象（如果有的话），并提供一段comment信息。

git提供了`commit-tree`命令创建一个提交对象。

所谓的版本历史就是commit对象构成的有向无环图。

git之所以区分提交对象与树对象我想仅仅是因为从建模意义上二者是不同的实体吧。

git是版本管理工具，我们关注的也是版本，也就是提交对象，提交对象执行树对象，树对象又引用所有的文件对象。由此可见，只有能从commit对象索引到的文件对象才是能被管理的对象。没有被任何commit索引到的对象称为悬空（dangling）对象。

<hr />

#### 标签对象

首先我们要区分标签引用与标签对象。标签引用分为两种：轻量标签与附注标签。前者仅仅是`refs/tags`下的一个文件，文件名字就是标签名字，
文件内容就是标签所指向的对象hash值。而后者的`refs/tags`文件内容指向一个标签对象，标签对象再指向我们要打标签的那个目标对象。标签对象的内容包括
标签名字、打标签者相关信息，指向的目标对象。

标签对象并非必须指向某个提交对象；你可以对任意类型的Git 对象打标签，当然也可以对另一个标签对象打标签。

创建标签对象用`git tag -a <name> <object> -m <message>`。

#### 对象的存储与包文件

上面谈文件对象时已经提到git是如何创建文件对应的文件对象的，可以看到git并不关心文件格式，统统当成二进制格式来处理，而每当文件有任何一丁点儿变动，git都会将为这个文件创建一个新的文件对象。这意味着一个庞大的文件会被存储多份，每份之间仅存在少量差异，显然这是不合理的。

这时候可以使用`git gc`，准确地来说，是`gc`有调用了[git pack objects][17]，因为`gc`其实会做一系列释放磁盘空间的动作，打包只是其中之一。

那打包是如何做的呢？ Git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。

### 两种“指针”文件

前面提到过提交对象与标签对象是一种“指针对象”，这种对象是用来标记版本历史中的位置。

但是这种“指针对象”本身也是对象，其名字是一个hash值，很难记，因此git中还提供容易阅读与记忆的`引用`与HEAD文件。

#### 引用

所谓引用就是一个文件，其内容是某个object的hash值，其名字是容易阅读的一个字符串。

git中共有三类引用：head引用、标签引用、远程引用。三类引用都存在`.git/refs`文件夹下面。

<hr />

head引用用来标记一个分支，其内容是一个提交对象hash值。注意区分head引用与`HEAD`文件。

<hr />

标签引用：有两类引用：轻量引用与附注引用。这两类引用都是文件，其内容都是对象hash值。不过附注引用，是先引用一标签对象，标签对象再引用目标文件。
标签引用都存储在`.git/refs/tags/`下面。

可以用`git tag`创建轻量引用，可以用`git tag -a`创建附注引用。

对于轻量引用，也可以用`git update-ref refs/tags/<tag name> <object hash>`来创建，甚至直接编辑`refs/tags/`下的文件。

<hr />

远程引用：我们知道，git是分布式版本管理工具，一个本地仓库可以对应多个远程仓库。每个远程仓库都有个名字，默认的那个远程仓库名字就叫做`origin`，并且每个远程仓库都有一个当前正在使用的分支。这些都记录在远程引用`refs/remotes`下面。一个远程仓库一个文件夹，`origin`对应的就是`refs/remotes/origin/`。

使用`git remote`来管理远程引用。当然也可以使用底层命令`git update-ref`。

远程引用的分支就是head引用，我们知道head引用是一定要指向一个提交对象的，这意味提交对象--或者说远程版本的这个分支的一份拷贝要先存储到本地仓库的objects中。

远程引用和分支（位于 `refs/heads` 目录下的引用）之间最主要的区别在于，远程引用是只读的。 虽然可以 `git checkout` 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，你永远不能通过 `commit` 命令来更新远程引用。 Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。

#### HEAD文件

head引用用来标记分支。而我们使用git时，总是在某一个分支下工作，这个分支就是当前分支，记录这个当前分支的文件就是`.git/HEAD`文件。

同样，我们的仓库对应多个远程仓库。当前使用的远程仓库以及其分支也记录在HEAD文件中，不过是`.git/refs/remote/仓库名/HEAD`文件。

之所以区分于引用，是因为引用文件中指向的是对象，而HEAD文件中指向的是引用。

## patch

基本上，git有两套处理patch的命令：不同版本管理软件通用的diff与apply；git独有的format-patch与am。实际上，apply也能应用format-patch生成的patch。

### 使用diff与apply

有关diff与apply命令参考文档与下面的《命令要点》小节。

使用patch的一般步骤：
要先`git apply --check`检查一下，能检查出来什么呢？


### 使用format-patch与am

am会自动提交，这个自动提交后形成的版本历史是什么样的呢？比如说，两个分支A与B都克隆自分支C，分支B先开发完后，B与C之间形成patch，然后将这个patch应用到A上，若是没有冲突则会自动提交，否则会先解决冲突。这种操作的结果与边基是类似的吗？


### patch包的内容

对于二进制文件，patch里整个替换。对于文本文件，只记录二者差异。那么git是如何确定一个文件是否文本文件的呢？
参考[stackoverflow: How to determine if Git handles a file as binary or as text?][18]。

## 合并与变基


## 情景分析


HEAD^这是种什么写法？



### 常用命令的低层命令伪代码

#### add

已经跟踪的情况下用add -A 与未跟踪的情况下用add -A

#### commit

#### fetch

#### merge

#### rebase

#### stash

#### restore

#### reset

#### checkout

#### branch -b

### 什么时候会读写index区

对一个仓库的操作：
add commit merge rebase stash restore reset checkout

add: 写

commit： 读与写 由于要创建树对象与提交对象，因此要写index。
写树对象会读index并校验对应文件对象是否存在，顺便检查冲突，检查已跟踪文件是否有未暂存内容

但其实，merge之前会检查已跟踪的文件是否有未暂存的内容（通过stat）。但其实add的时候文件已经添加到版本库，为什么不是直接将index中内容写到树然后提交呢？

merge：merge涉及三个分区


### 场景举例

#### 管理远程仓库

#### 

验证下上面说的暂存区文件会存储，但索引不会变更。

若是废除暂存区，已经存储的会怎么样？ 会传到远程仓库吗？


执行Add与执行Merge的过程区别：

一般而言，进入objects中的对象不会再发生变化，但可以验证objects中对象在gc中的清理


或者探究objects中对象何时删除，因为object对象太容易添加了，一个`git add`甚至`git update-index --add`就会添加。

这么容易添加，要是没有个删除机制是不可想象的。


合并分支的几种情况：1. A是B的祖先，2. A与B的共同祖先C既不是A也不是B
合并为什么是三方合并

为什么变基优于合并


生成patch、打入patch发生了什么

#### 删除误提交的大文件


#### 清楚历史中的大文件

### 玩转commit

# 实践

## 不要这么做（坏实践）

不要使用git rm

## 最好这么做 （好实践）

## 竟然还能这么做  （高级用法）

搜索

cherry-pick

打包

如何移除历史大文件

权限

revision修订

submodules:https://www.cnblogs.com/lsgxeva/p/8540758.html

搜索下其他的奇技淫巧

## 钩子


### core.fsmonitor-watchman

git update-index里提到了这个配置，似乎是个钩子

搞清楚它


# 协作模型

工作模型：
https://blog.csdn.net/qq_32452623/article/details/78905181

# 命令要点

文档中很多命令中都带有`[--]`这样一个符号，这个符号是用来区分版本路径与文件路径的。
可以发现命令格式中`[--]`后面必然跟着一个`[<path>]`，也就是文件路径要放在`--`后面。

## 底层命令

### hash-object

hash-object -w并不是仅仅将文件拷贝到objects下的目录中
可以看到空文件存储过去是有内容的

### cat-file
[doc: cat-file][4]

cat-file主要有两种模式：单对象模式与批处理模式。前者只能处理一个object对象，选项比较丰富。

**单对象模式**
```
-t [--allow-unknown-type]| -s [--allow-unknown-type]| -e | -p | <type> |

If <type> is specified, the raw (though uncompressed) contents of the <object> will be returned.
```

(--textconv | --filters ) [--path=<path>]的意义还没有弄清楚。

**批处理模式**
使用批处理模式时需要先指定如下选项：

```
--batch[=<format>] | --batch-check[=<format>]

format的格式是可选的，若不提供
--batch的默认格式为：%(objectname) %(objecttype) %(objectsize) [%(objectmode)] %(objectcontent)
--batch-check 顾名思义就是仅仅check一下，默认格式为：%(objectname) %(objecttype) %(objectsize)
```

然后cat-file将以交互式的方式，从stdin读取objects名，一次一个，一个一行，回车后按上述格式打印objects的信息。

如果想检查仓库中所有的objects:

```
git cat-file --batch-check --batch-all-objects
```

### ls-files

[doc: ls-files][5]

文档说的很清楚，“Show information about files in the index and the working tree”。

查看暂存区与工作区的文件。有多个命令选项，默认是查看暂存区的文件。

`(-[d|m|o])`这三个选项显示的是工作区与暂存区比较之后的差异：`-d`表示工作区已删除，`-m`表示工作区已经修改，
`-o`表示其他工作区与暂存区不同之处（新增但未跟踪的文件）。

`-i`用来显示满足`.gitignore`条件的那些实际上被忽略的文件。

`-u`仅显示unmerged文件。所谓“unmerge”就是指在merge中发生冲突而未能完成merge的文件，也就是冲突文件。

	问题一：冲突发生时，merge是半中断还是什么状态？仅仅是工作区与暂存区的合并？
	问题二：git标记unmerged file是另有索引还是根据文件内容里面的“<<<<< >>>>>”符号啊？


当修改了工作区或删除了工作区的时候，我们知道可以通过`git status`来看出哪些文件发生改变。


`-s`选项中提到了输出格式的stage number。stage number是用于merge过程中的一个数，参考[doc: git merge][6]。通常情况下stage number为0。

windows下可以会用[这个脚本](/assets/resources/git_in_one/stage_number.bat)来查看stage number在merge中的作用，只需要将脚本放在一个空目录里运行就可以了。对于一个merge冲突，涉及三方：共同的祖先、当前版本、要合并进来的版本，这三个版本里的同一个文件发生冲突后stage number分别为1、
2、3。

	从上面我们也可以知道，git绝不是根据冲突的文件的内容里标记上`<<<<>>>>`符号就完事的，冲突是在index中有明确记录的。

### ls-tree

[doc: ls-tree][11]

`ls-tree`默认显示指定树对象下面的所有文件与目录，不递归子目录。

`-r`选项递归显示子目录下的文件。用了这个选项会递归，但不再显示子目录，仅显示文件。

要想递归的同时显示所有的子目录与文件，使用`-r -t`。

`-d`选项仅显示目录，不显示文件。

该命令最后还可以跟一个路径，作为要搜索的文件的前缀，因此可以用来列出某个文件夹下的路径，或者在树中查找某个文件。若是查找的文件不知道确切路径，
可以列出所有文件然后配合grep来搜索。

### read-tree

`read-tree`并不会将树对象的信息打印出来，而是读入到index区中，注意这个过程并不会先清空index区。


第一个问题：index区中有相同的路径会怎么样？

### write-tree

[doc: write-tree][12]

`write-tree`真是git中少有的一个简洁的命令。

不带任何选项地直接执行`git write-tree`会将index里的文件对应的树对象（index里的entry已经按路径排好序了）写入到object区，并检查对应的文件对象是否真实存在。

`--missing-ok`则会忽略文件对象的检查。

`--prefix=<prefix>/`允许只写某个子目录下的文件。

`write-tree`写树对象是一定会写入子目录对应的树对象的，不存在只写目录树中间某一层树节点对象的办法。

### update-index

`git update-index file_path` 只是尝试在index中更新file_path对应的cacheinfo。

但这么命令似乎不像我们想象的那样“智能”：1. 将工作区没有的同步到index； 2. 将index区过时的信息更新,同时将文件对应的objects添加到仓库区 3.将index区多余的删除。
以上这些动作需要另外指定选项来实现。因此`git update-index file_path`的动作仅仅是前面的步骤2，也就是更新hash值以及将文件添加到仓库区，甚至不包括stat信息，这需要额外的选项`--refresh`。

注意`git update-index file_path`是会添加文件到仓库的，其背后运行了一次`hash-object -w`。

如果index中没有这个file_path对应的索引项的话，则会忽略，这就是文档说的“Default behaviour is to ignore new files.” 要想添加新文件到索引，需要使用`--add`选项。

如果index中有索引但是工作区没有对应的文件，想要删除索引的话，则需要选项`--remove`。

不仅要添加`--add`与`--remove`，还要给出单个文件的路径，虽然在我们开来这是可以自动对比实现的事情，但`update-index`似乎是个很谨慎的命令。

然而`--add` 不仅仅是添加index, 还会会添加对应的文件对象到objects。

若想只添加文件的cacheinfo到index，则应该使用`--add --cacheinfo`，然后按照`<mode bit> <object hash> <file_path>`的格式附上相关信息。
比如：

```brush:bash
git update-index --add --cacheinfo 100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 data0.txt
```

有意思的是，只添加索引的这个动作里那个hash值是不做检查的，意味着完全可以胡乱给一个hash1值。

那么如果我们给一个错的hash值会怎么样呢？我们来验证一下。

验证步骤：

* 创建一个空的文件夹，用`git init`初始化
* 创建一个空的txt文件，命名为`data0.txt`
* 用hash-object求出`data0.txt`的hash值
* 然后在`data0.txt`中添加内容`hello git`，这时候上面求出的hash值就会错误的了
* `git update-index --add --cacheinfo`添加`data0.txt`的错误的cacheinfo。
* 用`git hash-object -w`将`data0.txt`写入到objects中
* 上面的状态就是正常执行到`git add data0.txt`后的状态了，只不过index中的hash值是错的
* 用`git status`查看状态

windows下可以会用[这个脚本](/assets/resources/git_in_one/wrong_hash.bat)来复现这些脚本步骤，只需要将脚本放在一个空目录里运行就可以了。

```brush:bash
# git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

        new file:   data0.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   data0.txt
```

可以看到`data0.txt`既是modified状态，又是new_file状态。

这很好理解，所谓新增是相对于工作区相对于历史版本来说的，这里是相对于HEAD指向的提及（这里的HEAD为空）。

所谓修改是工作区相对于index与仓库区。

上面的验证步骤其实就是一个文件在添加到暂存区但是未能提及之后，又再次修改的这么一个场景。

由此我们可以推测index的存储结构以及更新逻辑：

```
index 以路径为key， hash值与mode-bit为内容。

如果一个路径index有，而工作区没有，则认为是删除。

如果一个路径工作区有，而index没有，则认为是untracked。

如果一个路径工作区与index都有，但是HEAD指向的树对象却没有，则认为是新增。

如果一个路径工作区与index都有，但仓库区没有，且二者工作区与index里的hash值不同，则认为是修改。

如果一个路径工作区与index都有，且hash值相同。仓库区也有，但仓库区的hash值不同，则认为是修改。

```

实际上，我们能找git references中找到index的[格式][7]。其中明确说了
index_entry按照路径排序，路径相同则按照stage number排序。是的，名字可能相同，这发生在merge 冲突的时候。

后两种修改：第一种是修改还未添加到暂存区，第二种是修改还未提及。

两者给出的提示信息不同：
```brush:bash
#前者
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   data0.txt
#后者
Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

        new file:   data0.txt
```

所以这时候只要再次`git add data0.txt`就好了。


其实，也可以用`git update-index ---info-only data0.txt`单纯只纠正index里的cacheinfo。

实际上，在上述的场景下，使用`git add`总是会更新cacheinfo并将文件添加到objects里。


那么如果不纠正，手动创建树对象与提交对象，然后删除工作区，然后从仓库区checkout会怎么样呢？
我们来验证一下：

验证步骤：

* 创建一个空的文件夹，用`git init`初始化
* 创建一个空txt文件，命名为`data0.txt`
* `git add data0.txt`将其添加到暂存区，文件添加到仓库区。
* 在`data0.txt`中添加内容`hello git`
* 用`git update-index --info-only data0.txt`只更新index区中的hash值
* 这时候data0.txt在仓库区没有新版本。
* 用`git write-tree`创建树对象。
* 用`git commit-tree`创建提交对象。
* 删除data0.txt
* 用`git checkout `

windows下可以会用[这个脚本](/assets/resources/git_in_one/wrong_hash_checkout.bat)来复现这些脚本步骤，只需要将脚本放在一个空目录里运行就可以了。

可以发现在`git write-tree`那一步就出错了，看来相应用这种方式“欺骗”git是行不通的。`write-tree`会在写入index的时候顺便校验对应的文件是否在对应的文件对象存在。


`git update-index`是一个复杂的指令，尽管[doc: update-index][8]上
已经做了很详尽的解释了，但还是有必要提几个地方：

`<file>`中不能包含`.`和末尾的`/`，也就是不支持一次更新一个文件夹。必须是清晰简单的单个文件的路径。

`--fsmonitor`与fsmonitor的钩子有关，到钩子那一节我们再介绍。

`--untracked-cache`指的是是否将未跟踪文件的相关信息也记录到index中，这其实是index的一个扩展功能，详细查看[index format][7]。

`--split-index`的含义参考[index format][10]。

`--index-version`指定index版本。是的，git的index格式在迭代变化，这个应该是为了兼容性考虑而设置的选项。

`--replace`指的是路径名与文件名冲突的情况。实际上，windows系统上本身就不允许同一目录下文件夹与文件重名。

但我们仍然可以验证这一点，验证步骤：
* 创建空文件夹，`git init`初始化
* 创建目录dir，目录下创建文件data0.txt
* `git add dir/data0.txt`
* 删除目录dir，创建文件dir
* 尝试添加索引`git update-index --add dir`
* git会报错
* 使用`git update-index --add --replace dir`，则顺利替换掉索引

windows下可以会用[这个脚本](/assets/resources/git_in_one/update-index-replace.bat)来复现这些脚本步骤，只需要将脚本放在一个空目录里运行就可以了。

实际上，上面第5步若是使用`git add -A`也不会有问题，因为git会先发现目录dir被删除从而删除对应索引，再添加文件dir自然不会冲突。





`--remove`与`--force-remove`：前者删除索引还要看工作区有没有。后者强制删除。删除索引并不会删除对应文件对象，这个在unresolve.bat脚本中有验证。


`--info-only`与`--cacheinfo`： 都是只建索引不添加objects对象，但是后者是直接给出索引内容，前者git自动构建索引内容。

`--index-info`:类似`--cacheinfo`，但可以指定的cache字段更多，功能更强大，参考文档“using index info”就可以了。

`--unresolve`: 我们知道冲突状态下，冲突的文件会在index里形成多个索引，其stage number不同，这个在上面的介绍`ls-files -s`中验证过了。如果这些index信息丢失了，我们就可以用这个选项恢复冲突文件在index中的索引, 值得注意的是该选项只能恢复stage number为2与3
的两条索引。stage number为1的索引是此次冲突的两个分支的共同祖先所对应的版本。当然我们可以找到这个版本，但其实也不需要，因为处理好冲突之后
提交修改的时候，会将所有data0.txt的索引都冲掉，不论是两条还是三条都一样。

	找到两个分支的祖先可以使用命令：git merge-base branch_1 branch_2
	在某个树对象下搜索某个文件对象：git ls-tree -r <tree object id> <path-prefix>
	

windows下可以会用[这个脚本](/assets/resources/git_in_one/unresolve.bat)来验证，只需要将脚本放在一个空目录里运行就可以了。

`--again`或者`-g`: HEAD commit中与index中路径相同但索引不同，至少有两种情况造成这种现象：新的修改添加到暂存区但是还未提及，也就是工作区与暂存区一致，暂存区与存储区不一致；暂存区的内容被手动误修改（通过`--cache-info`等），也就是工作区存储区一致，但与暂存区不一致。

以下四类命令都是关于index entry bit的，entry上有一些特殊的标志位（[index format][7]），下面这个选项用来对其进行操作。


`--[no-]assume-unchanged`: 设置该bit后，git将永远假设文件没有更新，因而不去更改这些index，`git status`也不会报告其真正状态。

`--[no-]skip-worktree`:

`--[no-]ignore-skip-worktree-entries`:

有关以上三个命令的资料：https://fallengamer.livejournal.com/93321.html  https://www.cnblogs.com/wt645631686/p/10007328.html 
https://www.zhihu.com/question/25234996

深入理解以上三个选项需要我们了解git其他命令如何读写index的，因此先跳过。

--[no-]fsmonitor-valid: 参考[这里][15]。


`--chmod=(+|-)x`:为什么有这个？这个不是通过linux就可以的吗？其实这是为某些不怎么好用的文件系统设计的，参见[这里][13]。

`--refresh`选项不像是字面意义上的那样（实际上很多git命令不像字面上看起来的那样，比如`hash-object`加个`-w`居然能写object）。


	`--refresh` does not calculate a new sha1 file or bring the index up to date for mode/content changes. But what it does do is to "re-match" the stat information of a file with the index, so that you can refresh the index for a file that hasn’t been changed but where the stat entry is out of date.

	For example, you’d want to do this after doing a git read-tree, to link up the stat index details with the proper files.

实际上`refresh`是用来刷新index中的文件的stat信息的。所谓stat信息，指的就是linux上的[stat命令](11)。

但老实讲，我不清楚为什么git的index要存储stat信息。

`--really-refresh`: 无条件检查index是否过时，忽略“assume unchanged”位。

一下三个选项都是配合`--refresh`使用的。

`--ignore-missing`: 原文档：Ignores missing files during a --refresh。问题：有丢失的情况下，直接运行`refresh`会怎么样？`refresh`命令会中止执行并报告需要更新index。注意，`--ignore-missing`选项要放在`--refresh`选项前面，否则会失效。

`--unmerged`: unmerged也就是冲突文件会有多个index，因此这个选项意义很明显了。

`--ignore-submodules`: submodules参考[这里][14]。


### commit-tree

[doc: commit-tree][9]

`git commit-tree`用来创建提交对象。


### merge-base

用来寻找两个分支的最近的共同祖先分支。

### update-ref


## 上层命令

### remote

### add

### checkout

区别于低层命令checkout-index。

前面讲三个区的时候讲过，暂存区与工作区是分支共用的。GIT的原则是确保工作区里的内容不会随便被丢弃，所以如果工作区里的内容都已经提交了，
那么此时checkout切换到另一个分支，工作区的内容会被覆盖。但是若没有提交，工作区的内容会保留，看起来好像checkout出的内容被修改。

 

### merge

### fetch

### stash

stash

stash之后，再度修改，再stash回来之前，要先提交，再stash会发生冲突吗还是二次修改？

两个小脚本搞定上面俩问题

### diff

在diff看来，一个文件的不同版本可能存在于工作区中、index中、不同的commit中，而diff能够就就其中任意两个地方的同一个文件进行比较。

工作区与index区进行比较：`git diff [<options>] [--] [<path>…​]`。

工作区与某历史版本进行比较：`git diff [<options>] <commit> [--] [<path>…​]`

index区与某历史版本进行比较：`git diff [<options>] --cached [<commit>] [--] [<path>…​]`

两个历史版本进行比较：`git diff [<options>] <commit> <commit> [--] [<path>…​]`

工作区与其他地方的比较是否包含未跟踪文件呢？不包含。

diff还能将工作区文件与git外部的文件进行比较：`git diff [<options>] [--] <path> <outside-path>`

从上面也可以看出，git命令非常有规律`--`之后是要比较的文件路径前缀; `--`之前是options与要比较的两个地方，有sha1值就会被当成commit。什么都不写表示工作区。`--cached`表示index区。但是工作区与index区的比较却不是`git diff --cached -- [<path>]`，这种写法表示index区与HEAD指向的commit进行比较。

重要的options是`-P| -u| --patch`生成patch包。

详细参考文档。

### apply

`--check`:

`git apply --cached`的实际效果？

### format-patch

### am


### gc
[doc: git gc][16]原文：

	Runs a number of housekeeping tasks within the current repository, such as compressing file revisions (to reduce disk space and increase performance), removing unreachable objects which may have been created from prior invocations of git add, packing refs, pruning reflog, rerere metadata or stale working trees. May also update ancillary indexes such as the commit-graph.

其中讲到“removing unreachable objects which may have been created from prior invocations of git add”，我们知道`add`确实会把文件添加到版本仓库，但是为什么会变成不可达的呢？正常路径应该是没有的，唯一的可能性是使用低层命令手动创建树对象但不创建提交对象或者了删除了某个提交对象。

但这个删除不可达对象，我测试了一些似乎不管用，测试方法：随便找一个object复制一下，将复制的文件胡乱修改一个不存在的sha1值，则该对象肯定是不可达的，然而在git gc中并没有被删除。

存疑。

# 参考

[0]:https://git-scm.com/book/en/v2
[1]:https://git-scm.com/docs
[3]:https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1
[4]:https://git-scm.com/docs/git-cat-file
[5]:https://git-scm.com/docs/git-ls-files
[6]:https://git-scm.com/docs/git-merge#_true_merge
[7]:https://git-scm.com/docs/index-format
[8]:https://git-scm.com/docs/git-update-index
[9]:https://git-scm.com/docs/git-commit-tree
[10]:https://git-scm.com/docs/index-format#_split_index
[11]:https://git-scm.com/docs/git-ls-tree
[12]:https://git-scm.com/docs/git-write-tree
[13]:https://git-scm.com/docs/git-update-index#_configuration
[14]:https://git-scm.com/book/en/v2/Git-Tools-Submodules
[15]:https://git-scm.com/docs/git-update-index#_file_system_monitor
[16]:https://git-scm.com/docs/git-gc
[17]:https://git-scm.com/docs/git-pack-objects
[18]:https://stackoverflow.com/questions/6119956/how-to-determine-if-git-handles-a-file-as-binary-or-as-text?r=SearchResults