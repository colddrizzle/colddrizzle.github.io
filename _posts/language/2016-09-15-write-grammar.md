---
layout: post
title: 如何构造文法
description: ""
category: language
tags: [language, compile, grammar]
---
{% include JB/setup %}

* toc
{:toc}

<hr />

本篇参考自蒋宗礼《形式语言与自动机理论》2.3节，但主要以写自己的理解为主。

串起本篇的是一个个例子，这些例子是循序渐进的。

## 关键与原则

构造文法主要是编写产生式，而产生式是对语言结构的描述，因此构造文法的关键是
分析语言的结构。

构造过程可以遵循以下原则：

* 对句子进行分类，尽量用一个语法变量表示一类句子

* 对每类句子结构进行拆分，尽量用一个语法变量代表句子中的一种成分

* 注意句子的自相似结构，这种往往是迭代构造


## 例子

**例 1**

构造文法G，使得$$ L(G) = \{ 1^n \vert n \geq 1 \}  $$

显然这个语言只有一类句子，都是形如`1, 11, 111, 1111...`这种形式，用E表示这类句子。句子具有自相似结构。
句子结构可以看做同类的一个句子，再加上一个`1`构成。因此得到产生式:`E -> E1`。
为了“终结”推导过程，还需要`E -> ε`。得到文法：

```
E -> E1 | ε

```

当然，如果你不喜欢空语句，也可以使用`E -> 1`，也能终结产生式。于是得到文法：
```
E -> E1 | 1
```


同样，也可以把句子的自相似结构看成是前面一个`1`在加上后面的一个同类句子，得到产生式`E -> 1E`。进而得到文法：
```
E -> 1E | ε

```

那么这两个文法有什么区别呢？

从语言（句子集合）的角度来看是没有任何区别的（因为左线性文法与右线性文法等价）。但是从推导\归约过程来看是由区别的。比如推导句子`1111`：

对于`E -> E1`
```
E
E1
E11
E111
1111
```

对于`E -> 1E`
```
E
1E
11E
111E
1111
```

可以看到前者相当于自左向右推导，后者相当于自右向左推导。对于句子生成来说，这种左右差异并无英雄，但对于句子的语法分析、语义分析来说，这种差异是非常重要的，后面我们会再提到。

句子的自相似结构，看做是`E -> EE`如何呢？其实是一样的，如此得到文法：
```
E -> EE | 1
```

**例 2**

构造文法G，使得$$ L(G) = \{ 1^n2^n \vert n \geq 0 \} $$

这个语言也只有一类具有自相似结构的句子，都是形如`12, 1122, 111222`的结构。后一个句子是在前一个句子的两边各加上一个`1`与`2`得到。
用`E`表示这类句子，得到产生式`E -> 1E2`。 进而得到文法：
```
E -> 1E2 | ε
```

当然不要空语句也可以是：
```
E -> 1E2 | 12

```

**例 3**

构造文法G，使得$$ L(G) = \{ 0^{2n}1^{3n} \vert n \geq 0 \} $$

句子的结构是`ε, 00111, 0000111111...`。句子前面的`0`两个两个的增加，后面的`1`三个三个的增加。
于是就跟例2很类似了。文法如下：
```
E -> 00E111 | ε

```

**例 4**

构造文法，描述括号配对嵌套。

该语言的句子是形如`(), ()(), (()()), ((())),...`的一些句子。

观察可发现句子中存在两类结构：`E -> (E)`与`E -> EE`。

综合在一起得到文法：

```
E -> E(E)
E -> ε
```

这个才是高级程序语言中各种括号匹配的真正文法，而不是例2那种`a^nb^n`形式。

这个“综合”的过程能否写的再清楚一些？

**例 5**

构造文法G, 使得$$ L(G) = \{ \omega \vert \omega \in \{ a, b, ..., z\}^+ \} $$

语言中的句子设为E，则语言的结构就是在E的后面添加上`a, b, ...z`
因此得到文法：

```
E -> a | b | ...|z

E -> Ea | Eb |... E|z

```
当然也可以改成右线性。



另一种思路，其实该语言等价于$$ L(G) = \{ \omega^n \vert \omega \in \{ a, b, ..., z\}, n \geq 1 \} $$

相比于例1，不再是固定的`1`重复n次，而是一个可取`a..z`的变量重复n次，那么将这个变量设为A，
则得到文法

```
E -> AE | A

A -> a | b | ...| z
```

**例 6**

构造文法G, 使得$$ L(G) = \{ \omega\omega^T \vert \omega \in \{ 0, 1, 2, 3\}^+ \} $$

显然，这个语言里的所有句子都是对称的。对于一个句子，两边各加上一个`0、1、2、3`仍然是该语言句子。

于是得到文法：
```
E -> 0E0 | 1E1 | 2E2| 3E3 |ε
```

**例 7**

构造文法G, 使得$$ L(G) = \{ \omega \vert \omega 是十进制有理数 \} $$

我们来看一个十进制有理数的结构：

```
正负符号 整数部分 小数点 小数部分

```

分别去构造各部分文法，然后合起来就可以了，不再赘述，详细参考《形式语言与自动机理论》例2-13。


**例 8**

构造文法描述加法表达式

对于不带括号的情况，可以构造出如下文法：
```
E -> E + E
E -> id | c

# c表示常量
```

带括号的情况，可以构造出如下文法：
```
E -> E + E
E -> id | c | (E)
# c表示常量

```

**例 9**

构造文法描述加减法表达式

对于不带括号的情况：
```
E -> E+E
E -> id | c

# c表示常量
```

对于带括号的情况：

```
E -> E+E | E-E
E -> id | c | (E)
# c表示常量

```

**例 10**

构造文法描述带括号的加减乘除算术表达式：

```
E -> E+E | E-E | E*E | E/E | (E) | id | c

# c表示常量
```

**例 11**
构造产生语言$$\{ a^nb^nc^n \vert n \geq 1\}$$的文法

```
S -> aBC | aSBC
CB -> BC
aB -> ab
bB -> bb
bC -> bc
cC -> cc
```
这个比较难想出来，构造过程参考教材即可。教材上讲根据这个文法适当修改可以得到如下文法：
```

S -> abc | aSBc
bB -> bb
cB -> Bc

```
我们看下这个“适当修改”过程是怎么样的？

## 思考

构造 $$a^nb^nc^nd^n$$ ？

## 优先级与无二义性文法

本小节我们将综合考察例8、例9、例10，以构造带优先级的无二义性文法。

[文法与分类篇][0]已经提到过，例8与例9与例10都是二义性文法。同时也提到了限定结合顺序就可以消除二义性。

就例8加法运算而言，如果我们要限定结合顺序为自左向右，就意味着左边的表达式要作为一个结果来参与右边的运算，
从树的角度来讲，就是作为一个子树，从产生式的角度来讲就是：
```	
E -> E + T
T -> id | c 
```

例9有两种运算符，但它们的优先级相同。如何保证有唯一的最左推导呢？其实与例8是一样的：
```
E -> E + T | E - T
T -> id | c
```



例10有4种运算符，其中乘除运算的优先级高于加减运算。要想保证有唯一的最左推导，就要保证乘除运算作为一个整体参见加减运算。

那我们先构造乘除运算这个“整体”，也就是构造乘除运算的文法，与加减类似：
```
F -> F * T | F / T
T -> id | c
```

构造乘除运算的时候，不要考虑加减运算的任何事情，仿佛就在构造只有乘除运算的文法一样。

然后将乘除运算作为一个整体来构造加减运算:
```
E -> E + F | E - F | F
```

然后合并两个文法：
```
E -> E + F | E - F | F
F -> F * T | F / T
T -> id | c
```

整个带优先级的文法是从高优先级到低优先级逐级构造的。

很容易仿造上面的过程，构造带括号的算术表达式文法，注意，括号的优先级最高。

## 总结

暂无。

[0]:/2016/09/13/chomsky
