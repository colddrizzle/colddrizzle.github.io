---
layout: post
title: 文法与文法分类
description: ""
category: language
tags: [language, compile]
---
{% include JB/setup %}

* toc
{:toc}

<hr />

本文是蒋宗礼版《形式语言与自动机理论》、《编译原理》关于文法以及文法体系部分的笔记。
一些概念的严格的形式化定义以及定理证明不再重复抄写，只侧重于描述自己的理解。

## 文法定义

### 语言与文法

在形式化语言的研究中，语言被视作句子的集合，或者说是字母表$$\Sigma$$的克林闭包的一个子集。

而文法是对语言结构的描述，一个文法是一个`(V, T, P, S)`四元组。需要注意的是开始符号S除了是开始符号之外并没有任何特殊的地方，
这意味着S既可以出现在产生式的左侧，也可以出现在右侧。

开始符号无特殊性也意味着文法的同构性，实际上从文法G的语法变量中任取一个语法变量A作为开始符号，都能得到A所推出的“子语言”，这就是下面提到的语法范畴的含义。这个“子语言”用的产生式仅仅是那些左边包含A的产生式。

注意结构描述不等同语言本身，因为一个语言可以有多个结构化描述。

反过来说，一个语言可以用描述结构的文法来表示，也可以用描述句子集合的方式来描述，比如语言$$ \{ a^n \vert n \ge 1 \}$$。
这两种描述都很有用，后面的语言分类就是根据文法描述来定义的，在《形式语言与自动机理论》中研究RL与CFL的性质更多的使用的是句子集合的描述方式。

### 相关定义、定理

#### 语法范畴

《编译原理》定义2.16首次提到语法范畴的概念，称语法变量为语法范畴，其实这里的定义还不够明确，定义2.18称L(A)为任意属于V的语法变量推导出的句子集合，又称
L(A)为语法范畴A所代表的的集合，所以可以认为语法范畴A就是就是A推出的句子集合。

#### 句子
由S推导出、只包含终结符的字符串。

#### 句型
由S推导句子的过程中，包含终结符与语法变量的“半成品”。

#### 推导、归约
文法是预言的结构描述，这种结构描述用来生成语言或者判断某句子是否是某文法的结果的过程，就是推导与归约。
从开始符号到句子的过程称为推导，从句子到开始符号的过程称为归约。

最左推导：每次都对当前句型的最左语法变量进行替换。那么如何用语言描述相应的最右归约呢？每次归约产生的新的语法变量都位于当前句型的最右边？实际上
并不是这样的。我们看《编译原理》54页给出的例子：

id_1 + c * id_2的一种最左推导：
```
E
E + E
id_1 + E
id_1 + E * E
id_1 + c * E
id_1 + c * id_2
```
相应的最右归约是其逆过程：
```
id_1 + c * id_2
id_1 + c * E
id_1 + E * E     <-- 归约产生的新变量并不位于最右边
id_1 + E
E + E            <-- 归约产生的新变量并不位于最右边
E
```

观察这个逆过程的最右归约你会发现并不符合我们前面说的“每次归约产生的新的语法变量都位于当前句型的最右边”这样一个描述。那么应该怎么描述呢？

不是每次产生的新语法变量在最右边，正确的描述应该是每次归约发生的位置在最右侧。

计算机系统往往从左往右扫描字符串，而在推导与归约中优先考虑归约，因为推导可能会经历很多次的试错。

一般最左归约、最右推导等应用于CFG而不是CSG， 因为按照最左推导的定义：每次替换句型中最左变量，在CSG中句型的最左变量可能因为上下文原因无法替换，能替换的是次左或次次左变量及其上下文。

因此称最左归约为规范归约，相应的最右推导为规范推导。所谓最左归约就是每次从当前句型中归约出一个语法变量，该语法变量在下一个句型的最左侧，因此每一次都是利用句型的最左边的终结符前缀来判断产生式的选取。

需要注意的是，即使是规范推导，也不意味着推导的过程只有一种结果。二义性的存在使得规范推导存在多种（实际上存在多种最左推导正是二义性的定义），《编译原理》2.6节的例子明显说明了这一点。

让我们来看一个规范归约的例子。

设有如下的表达式文法：
```
G：E-> id | c | +E | -E | E+E | E-E | E*E | E/E | E**E | (E)

其中c表示常量，**表示幂运算 
```
那么句子$$id_1 + c \ast id_2$$ 的最左归约过程如下：
```
将句型看做是终结符与非终结符组成的串。

开始时句型为： id_1 + c * id_2

将各个产生式的右部在当前句型中进行匹配，求其最左出现的位置，也就是最小下标，如果没有找到则为无穷大。
比如id在当前句型中的最小下标是0，c在当前句型中的最小下标是2, 其余都是无穷大。

然后应用最小下标最小的产生式，即E->id，得到句型

E + c * id_2

继续计算各产生式在当前句型中最小下标
id为4，c为2, 其余都为无穷大，因此应用E -> c，得到句型：

E + E * id_2

继续计算个产生式右部分在当前句型中最小下标
id为4，c为无穷大，+E为1，-E为无穷大，E+E为0，其余为无穷大，因此应用产生式E->E + E
得到句型：

E * id_2

之后类似，归约为E * E, 最终归约为E

```

规范归约、规范推导产生的句型称之为规范句型。

## 文法分类

文法是对语言结构的描述，文法分类就是通过对P中的产生式进行限制而来的。

在编译原理2.2节中定义了字符串`x`的长度为`|x|`。在文法分类中，也出现了“对于所有的`α->β	`, 均有`|β|>=|α|`”的描述，在2.3节我们知道，
`α、β`均属于`V∪T`的克林闭包。也就是说`α、β`其实是句型，但是书中并没有明确给出句型求长度的含义，

	在此我们将其理解为该句型所能推出的句子的长度，
	当然这个长度是是视句子不同而不同的，因此`|β|>=|α|`的含义是β所能推出的最短句子的长度不小于α所能推出的最长句子的长度。

在此我们理解为该句型包含的“符号”的数目，其中符号就是V与T中的符号。

### 文法分类与语言分类的关系

就像在上一节我们区分了文法与语言一样，我们也要区分文法分类与语言分类。

当我们说文法G是CFG时候，意味其产生式的构成复合CFG的定义，但是复合CFG定义的文法肯定也符合CSG的定义。

当我们说语言L是CFL时候，意味其可以被一个CFG所精确推导出，但也可能被RG所精确推导出，但也绝对能被CSG精确推导出。

当我们说语言L不是RL的时候哦，意味其不可被任何RG文法描述。

如果从句子集合的角度来看：CSL，CFL，RL都能描述$$\Sigma^* $$上的所有句子。但是从精确描述的角度来看，
或者说就语言的描述能力而言，有CSL>CFL>RL 能被低级语言描述的肯定能被高级语言描述。因此一个RL肯定是CFL，一个CFL肯定是CSL。

虽然一个上下文无关语言肯定是上下文有关语言的说法听上去有那么点怪异，但这完全是因为翻译命名的问题，CFL如果命名为“上下文绝对无关语言”，CSL如果命名为“上下文可以有关语言”，那么这种包含关系听上去就正常多了。


一个RL肯定是CFL，一个CFL可能是RL。那当我们说一个语言是CFL的时候，意味着什么呢？

当我们说一个语言是CFL的时候，既然高级文法总能描述低级文法，那绝不是在强调其最高能被CFG所描述。一个CFL可能是RL，那也绝不是在强调其最低能被CFG所描述。又因为CSG、CFG、RG的规则越来越简单，因此，当说一个语言是CFL的时候，是在说其至简能被CFG所描述。

《编译原理》定义2.21之后说把4种文法看做相应的文法类，四种语言看做相应的语言类，然后给出了如下的关系：

$$ RG \subseteq CFG \subseteq CSG \subseteq PSG $$

$$ RL \subseteq CFL \subseteq CSL \subseteq PSL $$

那么如何理解语法类、语言类呢？

一个语言L可以看做是$$\Sigma^* $$上的子集，那RL语言类就是这些子集的集合。虽然说一个语言是CFL，意味着其也可能是RL，但也意味着存在一些CFL，其绝不能被看做是RL。也就是说，CFL语言类包含RL语言类中没有的语言。因此上面的集合关系成立。


### 理解文法的描述能力

上节将高级语言能精确描述低级语言的所有句子，反之则不行。比如说存在一个CSL不能被看做CFL，存在一个CFL不能被看做是RL。

其实这里面比较典型的例子是如下三个语言:

$$ \{ a^n \vert n \geq 1 \} $$

$$ \{ a^nb^n \vert n \geq 1 \} $$

$$ \{ a^nb^nc^n \vert n\geq 1 \} $$

《形式语言与自动机理论》中应用泵引理可证明，$$a^n$$是RL，$$a^nb^n$$是CFL但不是RL，$$a^nb^nc^n$$是CSL但不是CFL。

虽然正则文法：
```
S -> aB
B -> aB | bB
```
能够推导出所有$$a^nb^n$$的句子，但也能推导出很多不属于$$a^nb^n$$的句子，也就是说这个正则文法不能精确描述该语言。

所以说文法的描述能力是指的其描述的精确程度，越高级的文法描述能力精确度越高。短语结构文法可以不多不少地精确描述$$\Sigma^* $$上的任意子集。

问题：$$a^nb^nc^nd^n$$是PSL且不是CSL吗？$$a^nb^nc^nd^ne^n$$呢？无限扩展下去会怎么样？

这个问题我们留到[文法构造篇][0]再做解答。

### 相关定义 、定理

#### 线性文法

注意区分线性文法与CFG、RG的区别。

线性文法除了要求产生式左边是一个单独的语法变量之外，还要求产生式右边只存在一个语法变量，而CFG不做限制。

正则文法除了要求产生式右边只存在一个语法变量，还要求终结符构成的字符串仅存在于语法变量的一侧。

因此线性文法是一种介于RG与CFG之间的一种文法。

左线性文法与右线性文法就是正则文法。


定理：左线性文法与右线性文法等价

定理：左线性文法与右线性文法混用得到的文法不是RG

## 语法树

根据文法分类的定义，很容易理解只有CFG、线性文法、RG这些比较简单的文法才能用树描述，CSG以及短语结构文法是不能的。

### 相关定义

#### 结果

#### 语法子树

#### 短语、直接短语

#### 句柄

## 如何理解上下文相关、无关
首先，我们需要注意到Chomsky文法分类体系是根据语言结构进行的分类，所谓的上下文也仅仅是结构上的上下文，而不是语义上的上下文。

为了理解这一点，我们考察$$ \{ a^nb^n \vert n \geq 1 \} $$ 与$$ \{ a^nb^nc^n \vert n\geq 1 \} $$两个语言的文法，因为已知前者是CFG但不是RG，
后者是CSG但不是CFG，因此我们只需要分别给出其CFG与CSG的描述就可以了，不用担心其还存在更低级的文法描述。

对于语言$$ \{ a^nb^n \vert n \geq 1 \} $$：

```
S -> ab | aSb 

```

对于语言$$ \{ a^nb^nc^n \vert n\geq 1 \} $$的文法，参考自《形式语言与自动机理论》2.3节最后一个例子：

```
S -> aBC | aSBC
CB -> BC
aB -> ab
bB -> bb
bC -> bc
cC -> cc
```

可以看到在这个语言描述中，后4个产生式前面的那个终结符看似多余，但绝不能省去，这就是说`B`只有在上下文环境为`bB`的时候才能替换成`bb`。这就是结构上下文相关的含义，而反观CFL的文法，则没有这种结构上的上下文限制，任意`S`出现的位置都可以直接替换成其产生式右部。

## 二义性- Ambiguity

问题：wiki上讲最左推导有多个才叫二义性？

if else 是不是固有二义性 最左推导怎么样
E+E呢？

《编译原理》中讲CFG存在二义性，那么显然根据文法类包含关系，CSG、PSG都存在二义性。问题是RG存在二义性吗？

要弄清RG是否存在二义性，首先一个问题是什么是二义性？《编译原理》上定义二义性是通过语法树来定义的，但我们前面提过语法树这种描述方式只有CFG、RG才有，但CSG肯定也是存在二义性的，因此这个定义是不太精确的。

首先同上下文相关无关一样，二义性是语言结构上的二义性，而不是语言语义上的二义性。

语言语义上的二义性的一个例子是自然语言句子“有多少穿多少”，这个句子结构上不存在二义性，但是“多少”存在语义上的二义性，导致这句话
既可以表达“尽量多穿”也可以表达“尽量少穿”。


所谓语言结构上的二义性就是一个句子在一个文法下存在至少两种不同的最左推导过程。而所谓的语言结构，也就是文法描述是可变的，就说一种语言可能存在不同的文法描述，其中一种文法是二义性的，另一种文法不是二义性的，《编译原理》中用到的算术表达式就是这样。

而有的语言，无论我们用什么样的文法去描述它，构造出来的文法总是有二义性的，这样的语言被称为先天二义性或固有二义性。

注意，二义性是文法的二义性，只有固有二义性的时候，我们才称之为语言的二义性。

有关固有二义性的证明方面的线索可以参考wiki词条：Ambiguous grammar。


注意，《编译原理》上没有讲清楚的一点是“存在两种不同的最左推导过程”，《编译原理》上的定义是“存在两种不同的推导过程”。
[wiki：Ambiguous grammar][2]上明确指出了这一点。同样，[这里][3]也指出了这一点。因此我们采用网络上的二义性定义。


按照上面的讨论，RG是可能存在二义性的。作为佐证，参考[stackoverflow][1]上的一个回答，对于如下正则文法：字符串`aa`存在二义性
```
S->aA|aB
A->a
B->a
```

但是同时也很容易理解，所有的正则语言，都存在无二义性的RG来描述它，因此所有的正则语言都不是固有二义性的。

### 二义性的例子
本小节的例子参考自[wiki][2]与[网络][3]还有《编译原理》2.6节。

#### 加法运算
给定加法文法:`E-> E + E | id`，以及句子`id + id + id`

存在如下两种最左推导。
```
# 最左推导一
E
E + E     <-- 此时最左变量E存在两种选择
id + E
id + E + E
id + id + E
id + id + id

相当于计算过程：id + (id + id) 

# 最左推导二
E 
E + E    <-- 此时最左变量E存在两种选择
E + E + E
id + E + E
id + id + E
id + id + id

相当于计算过程：(id + id) + id
```

可以看到加法运算的二义性是不同的结合顺序。

问题：加法表达式是固有二义性语言吗？答案是不是，事实上加法文法
改写成如下就不是二义性文法了：
```
E -> E + T
E -> T
T -> id
```

此时只存在一种最左推导:

```
E
E + T
E + T + T
T + T + T
id + T + T
id + id + T
id + id + id

此时相当于计算过程：(id + id) +id
```

我们来观察下二义性是如何被消除的。

可以看到，对于加法运算，只要保证结合顺序是从左向右的，那么前面的项的和总是作为下一次加法运行的左操作数来参与，从树的角度讲
前面的项的和总是作为后面加法运算的左兄弟节点参与运算， 而文法`E -> E + T`恰好保证了这一点。

#### 算术表达式
给定算术表达式文法：
```
G：E-> id | c | +E | -E | E+E | E-E | E*E | E/E | E**E | (E)

其中c表示常量，**表示幂运算 
```

可以给出句子`id_1 + c * id_2`的多种最左推导。

```
# 最左推导一
E
E + E
id_1 + E
id_1 + E * E
id_1 + c * E
id_1 + c * id_2

# 相当于计算 id_1 + ( c * id_2)

#最左推导二
E
E * E
E + E * E
id_1 + E * E
id_1 + c * E
id_1 + c * id_2

# 相当于计算 (id_1 + c) * id_2 这是错误的结合顺序。
```

可以看到算术表达式的二义性也是因为多种结合顺序。

从上面两个例子可以看出，最左推导存在多种的原因是某一步推导过程中，最左语法变量存在多种选择，但都可以推出最后的句子。


#### 悬挂Else
高级程序设计语言中的条件语句的一种文法描述为：

```
S -> if B then S | if B then S else S | E

# B为条件表达式
# E为一般语句
```

该文法是个二义性文法。对语句:
```
if x + y > z then if d = e then y = y + x else y = z + d
```

按照最左推导，其可以是：
```
S
if B then S
if x+y>z then S
if x+y>z then if B then S else S
if x+y>z then if d=e then E else S
if x+y>z then if d=e then y=y+x else S
if x+y>z then if d=e then y=y+x else E
if x+y>z then if d=e then y=y+x else y=z+d

# 相当于 if x+y>z then {if d=e then y=y+x else y=z+d}
```

也可以是：
```
S
if B then S else S
if x+y>z then if B then S else S
if x+y>z then if d=e then S else S
if x+y>z then if d=e then E else S
if x+y>z then if d=e then y=y+x else S
if x+y>z then if d=e then y=y+x else E
if x+y>z then if d=e then y=y+x else y=z+d

# 相当于 if x+y>z then {if d=e then y=y+x } else y=z+d
```

可以观察到这个二义性也是由结合顺序导致的。

问题：悬挂Else是固有二义性吗？答案仍然是不是。

类比前面的加法运算，只要我们保证else的结合顺序是唯一的，其也能消除二义性。那一种保证结合顺序唯一的方法就是
优先最近原则，也就是我们 接受上面的第一个推导过程。

那如何保证结合顺序唯一呢？一种方法是在语法分析阶段人为控制：每当读取到一个else的时候将其挂成距离最近的if表达式的右兄弟。

另外一种方法也是重写文法， 类比加法运算重写文法消除二义性的过程，我们可以得到如下文法：

```
S -> if B then T
S -> T

T -> if B then S else S
T -> E

# B为条件表达式
# E为一般语句
```

按照这个文法，上面语句的最左推导只有一种：
```
S
if B then T
if x+y>z then T
if x+y>z then if B then S else S
if x+y>z then if d=e then S else S
if x+y>z then if d=e then T else S
if x+y>z then if d=e then E else S
if x+y>z then if d=e then y=y+x else S
if x+y>z then if d=e then y=y+x else T
if x+y>z then if d=e then y=y+x else E
if x+y>z then if d=e then y=y+x else y=z+d
```

核心思想仍然是：保证与else最近的if总是一起构成一个子树，参与上层子树的运算。


**上面三个例子的无二义性无法的一般构造思路都是利用优先级，逐级构造，详细我们在[文法构造篇][0]再讨论**

#### 有多种推导过程但是非二义性
这个例子来自wiki。

文法很简单：
```
S → A + A
A → 0 | 1
```
对于这个文法产生的语言`0+0, 1+1 , 0+1, 1+0`里的每一个句子，都有两种推导，但只有一种最左推导。比如对于`1+1`:
```
# 推导一
S
A + A
1 + A
1 + A

# 推导二
S
A + A
A + 1
1 + 1

#但只有推导一是最左推导

```

#### 固有二义性例子

例子来源于《编译原理》。

可以证明，语言$$ \{ a^ib^ic^j \vert i,j \geq 1\} \cup \{ a^ib^jc^j \vert i,j \geq 1 \} $$是一个固有二义性的语言。所有的句子$$ a^nb^nc^n, n \geq 1$$都是二义性的句子。

表面上开起来固有二义性的原因是因为一个句子有多种合法结构，但是严格的证明并不简单，证明线索参考[wiki][2]，并不像表面上看起来那么简单，
知道有这样的例子就好了。

### 二义性产生原因的经验性总结

结合上节的例子我们可以经验性的总结出，除了固有二义性之外，二义性的产生的原因都是因为有多种结合顺序。

注意以上只是经验性的结论，并非全部二义性产生的原因。但于我们学习编译，已经是够用的了。


### 消除二义性的原则与手段

既然二义性产生的原因是因为多种结合顺序，消除二义性的原则自然是限定结合顺序，当我们限定到所有句子只存在一种结合顺序的时候，文法二义性就消失了。

关于限定结合顺序为什么能消除二义性的说明我们在[文法构造篇][0]再讨论。

限定结合顺序的手段有：重写文法和在语法解析时人为规定结合顺序。

重写文法的一般思路我们在[文法构造篇][0]再讨论。

语法解析时人为规定结合顺序，比如比如算符优先级、比如最近匹配原则、比如自右向左或自左向右结合，其实都可以看做是优先级。
悬挂Else的最近匹配原则可以看做是最近的if要比远的if优先级高，加法运算的自左向右结合可以看做是左边的+号比右边的+号优先级高。


### 二义性文法的判定

关于二义性文法的判定有如下结论：

* 一个文法是否是二义性是不可判定的

* 但存在一组充分条件，满足这组充分条件的文法是无二义性的

* 任意一个语言是否为先天二义性，理论上不可判定。但对于某些具体的简单的语言，可以证明其固有二义性。


所谓无二义性文法的充分条件就是[DCFG][4]文法。DCFG与LL、LR、SLR、LALR的关系我们到《CFG与自动机理论篇》再讨论。


## 空语句

本小节是对《形式语言与自动机理论》2.5节的梳理与理解。

定义2-9定义了空产生式。

定理2-5说明，任意文法都可以改造成所有产生式右部不含开始符号的文法，并且不改变文法类型与其推导出的语言。
证明的过程比较好理解，分类讨论。第二种情况中构造了一个新文法$$G'$$：

取$$S' \notin V$$, 得到$$ G' = (V \cup \{ S' \}, T, P', S) $$

其中，$$ P' =  P \cup \{ S' \rightarrow a \vert S \rightarrow a \in P \}$$

注意这个$$P'$$，因为在讨论S出现在P中产生式右侧的情况，因此新构造的$$S'$$就通过这些产生式与$$S$$发生了关联，并且“接管”了原来
$$S$$作为左部的的产生式。

剩下的证明就比较好理解了。

但是这个定理在这一节出现就比较突兀，不知道有什么用，我们先接着往下看。

定义2-10扩充了RG、CFG、CSG、RL、CFL、CSL的定义。那么为什么这个扩充是合理的呢？

该定义首先要求S不出现在G的任何产生式的右部，根据定理2-5，这是具有普遍性的合理要求。那既然S不出现在任何产生式右部，那么通过给P中扩充一个
$$S \rightarrow ε$$产生式，我们可以保证除了S，其他产生式不会推出ε，也就是仅仅向原来的文法推出的语言中添加了一条空语句。

由此可见这个扩充是不过分的、合理的。

定理2-6、2-7则是直接应用定义2-10进行的证明。

2.5节最关键的论述在最后：

实际上，对于任意文法G=(V, T, P, S)，G中的其他变量A，出现形如$$A \rightarrow ε $$的产生式也不会改变文法产生的语言。

理解上面这句话就要理解文法的同构特性，实际上，对于任意其他变量A，将所有与A相关的产生式聚合在一起构成$$P_A$$，其文法称为$$G_A$$。依据定理2-5，可以构造一个新的$$A'$$，使得$$A'$$不出现在$$P_A$$中任何产生式的右部并且不改变原来文法$$G_A$$类型与产生的语言$$L(G_A)$$。在依据定义2-6可知$$L(G_A) \cup \{ ε \}$$不会改变原语言$$L(G)$$的类型。

## 表达能力限制

未完成。

引起我讨论这个问题兴趣的原因是 Torben Mogensen的《Basics of Compiler Design》2.10.2节的讨论。

正则语言与CFG相比，表达能力主要限制在哪里？

RL不能描述匹配的括号对仅仅是个例，有没有规则可以描述呢？

CFG相比CSG，表达能力限制在哪里?

这节内容我们留到 了解了 DFA与下推自动机之后再来讨论。

## 总结

上下文、二义性都是语言在某一文法描述下的结构上的特性。
那这种特性本身可能就是文法描述引入的，换一种文法特性就变了。

只有固有二义性、固有上下文相关才是语言本身的特性。

[0]:/2016/09/15/write-grammar
[1]:https://stackoverflow.com/questions/559763/regular-vs-context-free-grammars/17890133#17890133
[2]:https://en.wanweibaike.com/wiki-Ambiguous%20grammar#An_unambiguous_grammar_with_multiple_derivations
[3]:https://www.geeksforgeeks.org/ambiguous-grammar/
[4]:https://en.wanweibaike.com/wiki-Deterministic%20context-free%20grammar






