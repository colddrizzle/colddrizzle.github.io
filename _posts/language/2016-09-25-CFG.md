---
layout: post
title: 上下文无关语言及其自动机理论
description: ""
category: language
tags: [language, compile, grammar]
---
{% include JB/setup %}

* toc
{:toc}

<hr />

本篇所有涉及的算法都在[这里][1]有python实现。

# 上下文无关语言

本节下面内容依据自蒋宗礼《形式语言与自动机理论》

## 上下文无关文法的化简

注意，下面的顺序是按照教程来的，但其实去除空产生式之后会产生新的无用符号与单一产生式，实际应用中应该将这一步骤
放在最前面，其次是去除单一产生式，最后时去除无用符号。

### 去无用符号
无用符号的概念包含两部分：不能从S推出、不能推出只包含终结符的句子

《形式语言与自动机理论》算法6-1与6-2分别从这两方面来去除无用符号。

算法6-1自一些能直接推出终结符号字符串的产生式出发，自底向上递归构造NEWV集合，则NEWV中的语法变量肯定能推出只包含终结符号的字符串。

算法6-2自一些开始符号作为左部的产生式出发，自顶向下构造NEWV与NEWT，则新构造的语法变量与字母表中的符号肯定包含在S的推导中。

具体使用的时候，必须先试用算法6-1，再使用算法6-2，而不能反过来。反过来后，算法6-2中的语法变量可能在算法6-1之后成为无用符号。

严格的证明可参考教材，不再赘述。

### 去ε-产生式

定义：形如$$A \rightarrow ε$$的产生式叫做 ε-产生式，又称空产生式（null production）。对于文法 G = (V, T, P, S)中的任意变量A，如果
$$ A \Rightarrow^+ ε$$，则称A为可空变量。

注意一个文法包含空产生式与该文法对应的语言是否包含空语句没有对应关系（注意区分空产生式与空语句）。

当一个文法G不能产生空语句的时候，存在方法可以消除所有空产生式。

当一个文法G能产生空语句的时候，可以先构造出语言L(G)-{ε}的不含空产生式的文法，然后对空语句进行特殊处理。

以上就是定理6-7所讲的内容。

定理6-7: 对于任意CFG，存在不含空产生式的CFG G'，使得L(G') = L(G) - {ε}。证明参考教材。

经过以上讨论，我们可以把所有的文法都先当做一个不包含空语句的文法去处理。但是不能产生空语句的文法却不能直接去掉所有的空产生式。例如：

```
S -> 0S1 | 0A1 | 01
A -> 2A | ε
```
此时，有$$L(G) = \{ 0^n2^m1^n \vert n \geq 1, m \geq 0 \} $$。

如果简单的删掉G中的空产生式，会得到文法：
```
S -> 0S1 | 0A1 | 01
A -> 2A
```
此时，有$$ L(G) = \{ 0^n1^n \vert n \geq 1 \} $$。（注意A永远都不会产生只包含终结符的字符串，因此A是无用符号）

显然这样做直接改变文法产生的语言。

究其原因，是因为去除空产生式使得A的推导永远不回终结，从而使A变为无用符号。

因此，去除空产生式的时候必须将其导致导致“无法终结”给弥补掉。

一般地，需要对形如$$A \rightarrow X_1X_2....X_m $$的产生式进行考察，从中找出所有可以派生出ε的变量X-可空变量，它们组成可空变量集合U，然后对于$$  \forall H \subseteq U$$， 从产生式$$ A \rightarrow X_1X_2....X_m $$中删除H中的变量。对于不同的H，将得到不同的A产生式，用这组A产生式替代产生式
$$A \rightarrow X_1X_2....X_m $$。假设A的右部包含x个可空变量（1 <= x < m），那能得到多少个不同的A产生式呢？因为`x< m`，可以同时都删去，因此共有
$$2^x$$个不同的A产生式。

但是，必须避免在这个过程中产生新的空产生式。也就是，当$$ \{ X_1, X_2, ..., X_m \} \subseteq U $$时，不可将$$ X_1, X_2,...,  X_m $$同时从产生式
$$A \rightarrow X_1X_2....X_m $$中删除。因为我们已经假定该语言没有空语句，不同时删除并不会造成任何影响。

以上描述了去除空产生式的一般算法，其中依赖于可空变量集。算法6-3给出可空变量集的构造方法。构造方法如同去无用符号中的算法6-1,是一种自底向上的构造方法，详细参考教材，不再赘述。

去除空产生式可能会产生新的无用符号与单一产生式。比如教程习题12(2)。

### 去单一产生式

定义6-10 形如$$ A \rightarrow B $$的产生式叫单一产生式。其中A、B都是语法变量。

单一产生式的定义并不意味着A只能推出B，只是A其中的一个选项可以是B，也不意味着B只能由A推出，实际上B可以由不同的变量推出，这不
影响单一产生式的定义。

单一产生式的问题主要是增加了句子的分析步骤。

去单一产生式的一般方法的描述定理6-8的证明的第一部分中。单一产生式可以形成链，末尾未必是终结符。去单一产生式的方法就是代换，指的注意的是
应用单一产生式代换的顺序并无影响。且代换只代换单一产生式中的部分，意思是：

```
S -> AB | B
B -> id

S -> B ->id形成单一产生式

S的右部只代换选项B，而不代换选项AB中的B
```


当删除单一产生式后，文法中可能会出现新的无用符号，还需要再次删除新出现的无用符号。

构造方法：设有文法G=(V, T, P, S)。 构造G' = （V, T, P', S），使得L(G') = L(G)，且G'中不含有单一产生式。

条件一：如果 $$A \rightarrow α \in P$$不是单一产生式，则将$$ A \rightarrow α $$放入P'。

条件二：如果 $$ A \Rightarrow^+_G B 且 B \rightarrow α $$不是单一产生式，则将$$ A \rightarrow α $$放入P'。

这里有两个个小问题：
第一个：如果在$$ A \Rightarrow^+_G B $$ 过程中，某一个变量出现很多次，可以不考虑它的第一次出现于最后一次出现过程中间所进行的派生。


第二个：如果在$$ A \Rightarrow^+_G B $$ 单一派生过程中，出现其他语法变量比如说C，首先应该现将$$C \rightarrow α$$放入P'。因为此时是C先满足了
	条件二。C处理完之后才是A满足条件二，再将$$ A \rightarrow α $$放入P'。


### 综合考虑

CFG文法的化简包含以上三个主题，然而简化一个CFG并不是逐一应用各个方法就可以的。

由于去除空产生式会产生新的无用符号与单一产生式。去除单一产生式也会产生无用符号。因此三个主题的顺序应当是：
去除空产生式、去除单一产生式、去除无用符号。

## 范式文法

正则语言的文法是非常规范的，这个正则语言的分析带来了极大的方便。受此启发，希望找到CFL的规范文法--范式文法。注意，范式文法不是新的文法种类，而是
CFL的文法的某种规范格式。

### 乔姆斯基范式文法
定义 6-11：如果CFG G=(V, T, P, S)中的所有产生式都具有形式：$$A \rightarrow BC  A \rightarrow α $$，则称G为乔姆斯基范式文法，简记为CNF。

显然乔姆斯基文法天然的不含有空产生式、单一产生式。如果能保证乔姆斯基范式文法不含有无用符号，那就是化简后的文法。

定理 6-9 对于任意的CFG G，$$ε \notin L(G)$$, 存在等价的CNF G'。证明参考教材，该定理说明CNF对所有的CFG具有普适性。

对于CNF的了解到此就可以了，重要的是下面的格雷巴赫范式文法。

### 格雷巴赫范式文法

定义 6-12: 如果 CFG G=(V, T, P, S)中的所有产生式都具有形式 $$A \rightarrow aα$$形式，则称G为格雷巴赫范式文法，简记为GNF，其中$$ A \in V, a \in T, α \in V^* $$。

根据定义，在GNF中，只存在如下两种形式的产生式：

$$ A \rightarrow a$$

$$ A \rightarrow aA_1A_2...A_m (m \geq 1)$$


因此右线性文法是一种特殊的GNF。同CNF一样，GNF中天然的不含空产生式和单一产生式。

使用GNF文法，非常方便于最左推导。

GNF文法也是下面要讲的下推自动机能直接处理的CFG文法。

#### 改造成GNF

GNF文法不含有空语句，而前面定理6-7已经证明任意CFG构造的语言都可以用不含空语句的语言外加一条空语句来替代。
因此CFG改造成GNF的过程中，我们完全可以假设CFG不包含空语句（空语句单独处理）。

教材为了说明改造过程，先证明了两个引理，直接去看两个引理并不好理解它们的作用。我们去看定理6-10的证明，也就是任意CFG转GNF的证明，在证明中说明
它们的意义。

定理6-10的证明分成三步进行。注意每一步之后产生式的形式的变化。

第一步很简单，不再细说。

第二步做了什么呢？在k与j的双重循环并消除左递归的过程中，递推地将所有的A产生式改造成了不能由其前面变量开头的形式。注意理解这个递推的过程，可以将k = 1, k=2带入算法理解一下，$$A_1$$比它更前面的变量，其产生式只能由$$A_1$$以及之后的变量开头，由$$A_1$$开头则形成了左递归，左递归消除后$$A_1$$的产生式至少由$$A_2$$开头。同样，$$A_2$$的所有由$$A_1$$开头的产生式，按照引理6-1进行了替换，而$$A_1$$至少由$$A_2$$开头，因此$$A_2$$的所有产生式至少由$$A_2$$开头，消除$$A_2$$的左递归后，$$A_2$$的产生式至少由$$A_3$$开头。后面以此类推。

之后所有的$$A_i$$产生式都满足生成顺序，既$$A_i$$肯定由它本身或后面的变量开头（这个变量的顺序是算法6-4中由遍历变量的顺序的决定的）。
那么对于最后一个变量$$A_m$$，其不可能有比它还大的变量，因此其不可能是变量$$A_i$$开头。也不可能是新引入的变量$$B_i$$开头，因为新变量是消除左递归引入的，而消除左递归的都是$$A_m$$前边的变量。因此$$A_m$$的产生式肯定是终结符开头的，理解这一点就好理解第三步了。

第三步中是个由后向前的过程。前面已经分析过，$$A_m$$的产生式肯定是终结符开头。在第三步这个由后向前的代换过程中，保证了所有$$A_i$$产生式都是由终结符开头。

怎么理解第三步中改造B的部分呢？第二步中步骤⑤可以看到所有新引入的变量B都是以$$α_i$$开头的，而$$α_i$$是由$$A_i$$开头的，因此，新引入的变量B要么是终结符开头，要么是变量$$A_i$$开头，从引理6-2也可以看出，新引入的变量B全部在产生式的末尾，因此B产生式不会有递归。而所有的$$A_i$$都是终结符开头，因此应用引理6-1进行代换改造就可以了。

## 自嵌套文法
定义说明了什么是自嵌套文法，其实等同于格雷巴赫范式文法改造中提到的递归文法。

定理：非自嵌套文法肯定是正则语言。非自嵌套文法其句子长度必然是有界的，故而句子长度有界的语言必然是正则语言。
注意，不存在句子长度无限而句子总数有限的情况，一般地我们可以说，有限的语言都是正则语言。

# 下推自动机

## 定义

## 栈符号表

## 栈的意义


# 常用的CFG语法分析方法

自顶向下分析与自底向上分析法都是目前构造编译程序的实用方法，它们都只能处理上下文无关文法的一些子类。

那为什么不使用下推自动机呢？

## 自顶向下的语法分析

所谓自定向下的分析就是自开始符号出发，若能推导出目标句子，则目标句子的语法结构（语法树）也就分析出来了。
若不能推导出目标句子，则说明该句子不是该文法所接受的句子，通常报语法错误。

对于给定CFG文法G与一个句子s，所谓自定向下的语法分析就是判断该句子是否在该文法所描述的语言中的这么一个过程。

显然，我们可以从开始符号出发，尝试列举出该文法描述的每一个句子，若在列举的过程中遇到一个句子与我们的目标句子相符合，则推导完成。

然而这种枚举方式存在很多问题，比如无穷递归导致的死循环，但其中一个问题这种枚举方式没有利用到目标句子的任何信息，是盲目的选择产生式来枚举的。目标句子我们已经知道了，如果推导的过程能够利用到句子里的终结符来选择产生式，毫无疑问将大大加快推导的过程。

然而对于CFG文法来说，其产生式的右部的首字符未必是终结符，如何将目标句子中的信息利用起来呢？这就是下面要讲的问题。


### 自顶向下分析面临的问题

#### 二义性

[文法分类篇][0]已经讲过，CFG文法是由二义性的，并且也提到一个文法是否二义性是不可判定的。

既然是不可判定的，对于一个文法我们如何得知其可能有二义性呢？从实践的角度讲，如果一个语法分析器每次以固定的“偏好”应用产生式，虽然一个文法有二义性，但是二义性句子的推导只会有一种过程。那除非这种过程是我们不希望的，否则二义性的处理甚至是可以忽略的。

再者，《文法分类篇》提到过不同的结合顺序是二义性的一个根源，从语言的角度考察优先级问题也是避免二义性的一个方法。

二义性与产生式的候选项的关系：一个产生式有多个候选项未必会导致二义性，但是一个产生式只有一个候选项肯定不会导致二义性，这很容易理解，这样的产生式肯定只由一个确定的最左推导。条件再放宽些，如果在一个最左推导过程中，每一次应用产生式都是确定无疑的选择，那么肯定只有一个最左推导，也就没有了二义性，实际上，LL(1)文法就是这样保证没有二义性的。

#### 回溯

前面“自顶向下的语法分析”小节已经提到过，如果推导过程抛开目标句子，只看推导结构与目标句子是否匹配，推导过程是一定会有回溯的。

因此回溯存在的原因也可以认为是推导过程中应用产生式是“尝试性”的应用，而LL(1)将每一步应用变成确定性的应用，因此LL(1)也没有回溯的必要。

因此，减少回溯的思路就是尽可能的确定每一步可应用的产生式，确定产生式的方法就是依据目标句子的字符顺序。

每次应用产生式替换的时候确保该产生式的右部选项确实能够产生句子里相应的字符。比如一个句子以字符`a`开头，开始符号S有三个选项，其分别以`a`，`b`，
`c`开头，显然此时不能应用第二第三个选项。然而，产生式的右部选项并不总是以终结符开头，当右部以非终结符开头的时候，我们需要计算该非终结符所推导出的所有的句子的首终结符，也就是后面要讲的First集的概念。

同样，“右部选项以非终结符开头”这种情况也导致“提取左因子”消除或推迟回溯变得不可行。

但是这里我们可以采用前面提到的CFG文法化简中去单一产生式类似的方法，看个例子。

蒋宗礼版《编译原理》第四章习题13文法G1:

```
V -> N | N '[' E ']'  
E -> V | V '+' E  
N -> i

显然里面有单一产生式 E -> V -> N -> i。

消去N->i之后：
V -> i | i '[' E ']'

这时候就可以提取左因子了，

V -> i A
A -> ε | '[' E ']'

这两个产生式的各个选项都已终结符开头。

然后对于E -> V | V '+' E 中代入上面的V

E -> i A | i A '+' E  

提取左因子：

E -> iA B

B -> ε | '+' E

因此改造后的文法为：

E -> iA B

B -> ε | '+' E

A -> ε | '[' E ']'

可以看到每个选项的首终结符不再相同。

当然这里产生了空产生式，是否应用空产生式需要考察Follow集，这是另外一个问题了。

```


#### 无穷递归

无穷递归的存在是客观的。但这个陷阱其实也取决于实际推导过程中应用产生式的顺序，
如果在推导出句子之前可能根本碰不到这个陷阱。

消除左递归的技巧如下：

本质上是因为左递归与右递归等价，也就是 xxx 与 xxx产生的句子是完全一样的。

所谓消除左递归其实是将左递归改成右递归。


算法4.1的基本思想是为语法变量编号，再采用代入法将间接左递归变为直接左递归，然后采用上面接受的方法消除直接左递归。

通俗理解下这个算法，所谓递归就是个环嘛，选定一个语法变量A作为开始，逐步代换，最后肯定会只剩下这个变量A的直接递归。
而直接递归的消除方法就是将左递归变为右递归。


算法4.1要求输入的文法G是不含循环推导的与空产生式的文法。

空产生式就是A最终能推出ε的产生式。

循环推导就是A最终能推出A的产生式，注意是推出只含有A的产生式。`A -> '(' A ')'`不是循环推导。

消除空产生式在蒋版《形式语言与自动机理论》中有讲，但是如何消除循环推导呢？

其实，循环推导可看做是递归的一种特殊形式，也可看做是单一产生式的特殊形式(实际上，间接循环推导的那整个推导链肯定是单一产生式链)。按照代换法，逐步代换总能将间接循环推导改写成直接循环推导，
然后直接删掉直接循环推导就可以了。

当然这样代换消去循环推导可能会产生无用符号，但这是另一个问题，上面文法简化部分已经讲过了。

实际上，算法4.1稍作修改就可以接受含有循环推导的文法。方法就是在消除直接左递归那一步也删除直接循环推导。

算法4.1也出现在蒋版《形式语言与自动机理论》中CFG转格雷巴赫范式的算法中，基本是一样的。


#### 理想的自定向下分析

理想的自顶向下分析应该是这样的：对于任意给定一个CFG与一个句子，从开始符号出发，每次确定地应用一个产生式，直到发现能够推导出给定句子或者不能推导出给定句子（可终结，没有无穷递归）。且，当能推导出给定句子时，仅存在这样一种推导方式（无二义性）；当不能推导出给定句子时，绝不会替换其中某一步的产生式选项就可以推导出来（没有回溯）。

因此关键在于，如何每次确定地应用一个产生式，也就是根据什么来选择这个产生式。


### First集、Follow集

这三个集合与我们要讲的LL1没有必然的联系，只是为了后续的讲述方便而引入的概念。实际上，这三个概念对任意一个CFG都有。
当某个CFG的这三个集合满足一定条件时，就是LL1文法。

给定一个由终结符与非终结符组成的字符串γ，FIRST(γ)是从γ可以推导出的任意字符串中的开头终结符组成的集合。

FOLLOW(X)是可直接跟随于X之后的终结符的集合。

注意，当我们说求FIRST集时，γ是句型，意味着可以是是单个语法变量也可以是单个终结符。当我们说求FOLLOW集时，X只能是语法变量。

另外，First集可以包含ε，但是Follow集不会包含ε，但是可以包含句子结尾标记符#。实际上，ε与#都不是普通的终结符，而是起一个代位的作用。
为什么称之为“代位”呢？还是要考察First集与Follow集的本意，就一个语法变量X而言，First(X)指的是从X可以推导出的所有句子的第一个字符的集合，
空句子，若有的话，当然也是其中一个句子，但空句子没有任何开始符号，但空句子又确实存在，因此需要一个代位的终结符ε来表示这种情况；Follow(X)指的是文法G中所有的句子里跟在X后面的第一个字符的集合，当然，若在某一个句子里，X就是最后一个语法变量，其后面不再有任何终结符，因此也需要一个代为的终结符来表示，这就是#。


由于蒋版教材上的算法非常烂（排版混乱、某些字符定义不清、偏数学描述），下面我们给出各集合的算法。

```
终结符的First集显然只包含终结符本身，当然这里的终结符不包括ε。

对文法G，其语法变量集合为V，对V中所有语法变量的First集的算法如下：

1. 对所有的X属于V，初始化Frist(X) 为空集
2. 对于P中任意简单产生式X->α，对于α中的每一个符号s：
	2.1. 若s为终结符，则将该终结符放入First(X)，继续考察下一个产生式，也就是跳转到步骤2
	2.2. 若s为非可空的语法变量，则将First(s)并入First(X)，继续考察下一个产生式，也就是跳转到步骤2
	2.3. 若s为可空的语法变量，则将First(s)-{ε}并入First(X)，继续考察一个字符s，也就是跳转到步骤2.1
	2.4. 若α中的所有字符都是可空语法变量，则将ε放入First(X)
3. 重复步骤2直到各个First集的大小不再变化为止

```

可以看到我们的First算法是对产生式集合P来循环的，而不是像教材上那样，对语法变量来循环的。很容易证明这两种算法等价，而且我们的循环处理方法要简单一些。


很自然地，我们可以想到对于任一句型α的First集的算法，只需要新引入一个变量B->α，显然B不会出现在任意产生式的右部，
也就是B不会影响G中其他任意语法变量的First集合，因此按照上面的算法求First(B)就是在求First(α)。

当然在求出了V中各First之后，再求First(B)，就是蒋版《编译原理》算法4.3的内容了。

Follow集的求法依赖于算法4.2与4.3。

```
对文法G，其语法变量集合为V，对V中所有语法变量的Follow集的算法如下：

1. 对所有的X属于V，初始化Follow(X) 为空集，将#放入Follow(S)
2. 对于所有的X属于V，重复下面的步骤直到各个Follow集不再变化为止
	对于P中的每个产生式，若有：
	2.1. A -> αXβ，则将First(β)-{ε}放入Follow(X)。(注意，β是句型，且不管β是否可空)
	2.2. A -> αX 或者 A -> αXβ且β可为空，则将Follow（A）并入Follow(X)，并将#放入Follow(X)
```

以上算法是教材上的算法，同样我们可以给出遍历产生式集合P的算法，同样实现起来更简洁一些。

```
对文法G，其语法变量集合为V，对V中所有语法变量的Follow集的算法如下：

1. 对所有的X属于V，初始化Follow(X) 为空集，将#放入Follow(S)
2. 对于所有的p属于P，重复下面的步骤直到各个Follow集不再变化为止
	对p的右部的每个语法变量X，一般地，可以认为p与X的形式是 A->αXβ，考察其后面剩余部分β
	2.1. 将First(β)-{ε}放入Follow(X)。(注意，β是句型，且不管β是否可空)
	2.2. 若β可推出空（β是空或者β中不含终结符且所有语法变量都是可空的），则将Follow（A）并入Follow(X)，并将#放入Follow(X)

注意2.1是一定执行的，2.2是根据β是否可空来执行的
```

由以上算法可知，Follow集中不会含有ε字符，但是会含有#字符。

### LL(1)文法与Select集

SELECT(X->α)是对简单产生式而言的，也就是自定向下的推导过程中，选择该产生式的依据。
如果ε属于α，

SELECT(X->α)的算法如下：

```
如果ε不属于α，则Select(X->α) = First(α)

如果ε属于α，则Select(X->α) = (First(α)-{ε})∪Follow(X)
```

有以上可知，Select集中不会含有ε字符但是会含有#字符。

### LL(1)文法与语言的判断

需要注意，任意给定一个CFG文法（很容易判断其是否为CFG文法），未必有对应的等价的LL(1)文法。

但是我们可以通过求Select集来判断其是否为LL(1)文法。

因此，“改造某CFG文法为LL(1)文法”是伪命题，不存在这种方法，若经过判断，某CFG是LL(1)文法，则也不需要任何改造，因为产生式选择是根据Select集来的。
也因此，**蒋版《编译原理》整个4.2.2节都没有存在的必要，这个4.2.2节反而会误导初学者**。

但是注意，文法是文法，语言是语言，并不存在判断某一语言是否为LL(1)语言的算法。

LL(1)文法是CFG文法的子集，这很容易理解，因为LL(1)文法是SELECT集满足某种条件的CFG文法。

### 有关LL(1)的其他资料

关于LL(1)文法的一个[HIT教学视频][2]。

关系图法求First Follow集合参考[这儿][3]。

### 方法：递归下降法

关键是文法。文法必须是LL(1)。

文法是LL(1)后，还需要改造文法 使得每个产生式右部都已终结符开头吗？

### 方法：预测分析法

构建预测分析表其实就是Select集。

## 自底向上的语法分析

### 方法：LR

### 方法：SLR

### 方法：LALR


[0]:/2016/09/13/chomsky
[1]:https://github.com/colddrizzle/FLACT/
[2]:https://www.icourse163.org/learn/HIT-1002123007?tid=1461155445#/learn/content?type=detail&id=1237477153
[3]:https://www.jianshu.com/p/499cbb2cb12a