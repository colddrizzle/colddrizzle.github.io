---
layout: post
title: 克拉茨猜想瞎想
description: ""
category: 数学
tags: [数学]
---
{% include JB/setup %}

<hr />

克拉茨猜想

## 定义
我们称对于任意自然数n通过克拉茨算法得到的一系列数为克拉茨数列K(n)。
比如数5，其变换得到的数列为 5,16,8,4,2,1。K(n)中第一个2的幂记为Z(n)，并称n被Z(n)掌控。

不同的自然数，可能有相同的Z(n)。若Z为f，则记被f掌控的自然数的集合为R(f)。

## 基本思路1

若n为奇数，则3n+1, 若n为偶数，则n/2。显然奇数时变换得到的下一个数肯定是偶数。
而偶数时变换得到的数不一定为奇数。

直观上猜测得到的偶数要比奇数多，因此进行的除法操作要比乘法操作多得多，只要多到一定程度，
那么这个变换下去就一定会收敛到1。

或许可以从得到的奇偶数的分布概率方面考虑一下。实际上，用程序来测试前1千万个自然数，会发现
除法操作的次数至少是乘法操作的1.67倍，我猜测这个倍数可能就是5/3，也就是1.666....。

那么能否证明如下两个问题呢？
1. 任意给定初始值，应用克拉茨算法，得到的除法操作的次数至少是乘法操作的5/3倍

2. 只要满足条件1，那除法操作就多到足够使得最终结果收敛。


## 基本思路2

从概率的角度来看。对于任意给定的自然数，有如下性质：

1. 该自然数是奇偶数的概率各为1/2。
2. 若该自然数是偶数，则其除以2得到奇偶数的概率也各为1/2。

那能否证明克拉茨算法的产生的数也满足上述两个性质呢？

或者退一步讲，克拉茨算法产生的数列K(n)，对于性质1,2其概率还是1/2吗？

很显然的是，一个奇数后面必然跟着一个偶数，而偶数后面未必是奇数。因此K(n)中的奇数概率必然不大于1/2。

如果我们知道K(n)中偶数的分布性质，也许就有办法知道偶数做除法后获得的奇偶数的比例，我们就能知道乘除法的比率，从而转向基本思路1。


## 基本思路3
反正法。假设克拉茨猜想正确的情况下，也就是克拉茨算法最后一定会遇到一个2的幂，从而跌入不停除法的山谷，最终变为1。


对于任意给定的数n，通过克拉茨算法得到的第一个2的幂我们记为Z(n)。我们来看看遇到的第一个2的幂有什么性质。

既然是第一个2的幂，则Z(n)不可能是通过除法产生，也就是一定有 $$(Z(n)-1) \mod 3 = 0$$，满足这样条件的Z(n)可以证明（4的幂对3取模只能是1或者2）一定是4的幂。

4的幂按升序排列，为`4,16,64,...`。克拉茨算法中产生的第一个4的幂的前一个奇数为`1,5,21..`，也即是满足后一项是前一项的4倍加1。

关于这条思路，现在只知道这么多。

## 基本思路4

基本思路3中我们发现Z总是4的幂。现在我们来看对于给定任意一个$$4^n,n=1,2,3...$$，其掌控集R的特征。

通过下面附录的程序，我们可以观察到如下有趣的特征：

* R(16)非常大。也就是大部分自然数的都被16掌控。实际上，程序计算的结果显示至少在1亿的范围之内，大约93%的自然数被16掌控，而且这个比例分布的非常均匀。均匀的意思是任意取出一段足够长的连续的自然数，其中约有93%的数被16掌控。

* R(64^n)非常小且非常有规律。比如64为例。除了包含64以及64的二倍数128之外，其余的数都是21·2^n的形式，也就是本质上只包含一个21。至少在计算机验证的1亿的范围内，这个性质成立。

* 会出现连续的两个或三个自然数其Z相同的情况，这看起来感觉很不可思议，有点孪生素数那味了。

<pre class="brush:python;">
fate = {3: 16}

four_power=[]

# 准备一些4的幂，用于判定Z(n)
def init_four_power():
    f = 4
    for i in xrange(1,24):
        four_power.append(f)
        f *= 4

def insert_K(K, fate_value):
    for i in K:
        if i not in fate:
            fate[i] = fate_value

#打印K(n)
def K_sequence(n):
    while n != 1:
        print n,
        if n % 2 == 0:
            n /= 2
        else:
            n = n * 3 + 1
    print "\n"

# 计算K(n)中的Z(n)
def K_sequence_Z(n):
    K = []
    x = n
    while x != 1:

        K.append(x)

        if x in fate:
            insert_K(K, fate[x])
            return fate[x]
        
        if x > four_power[-1]:
    		print "error"
    		exit()

        if x in four_power:
            insert_K(K, x)
            return x

        if x % 2 == 0:
            x /= 2
        else:
            x = 3 * x + 1


if __name__ == '__main__':
    init_four_power()
    print four_power
    c = 0
    for i in xrange(3, 1000):
        r = K_sequence_Z(i)
        if r == 16:
            c += 1
            #print i, K_sequence_Z(i)

    print c
    #K_sequence(96971)
</pre>

