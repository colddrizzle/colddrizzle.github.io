---
layout: post
title: 汇编基本概念

tagline: "Supporting tagline"
category : 其他
tags : [linux, as, asm, ld]

---
{% include JB/setup %}

* toc
{:toc}

<hr/>
汇编的一些基本概念，主要是X86相关的资料索引。

## 汇编语言类别
不像其他上层语言那样，说出语言名字几乎就能确定该语言的所有风格与特性。
对于汇编来说，其风格特性则由三部分决定:CPU、语法、汇编器，也因此，当我们说某种汇编往往指的是汇编器的名字
或者语法的类别。

不同的CPU提供的指令不同，这很好理解。所谓语法通常有AT&T、intel、TASM三种语法，
语法只是写法上的不同，不同的语法写出来的程序编译链接后能在同一个平台上运行。
汇编器往往也会提供一些宏或者指令来简化汇编程序。

AT&T与intel语法上的差异可以参考[这里](http://blog.chinaunix.net/uid-27717694-id-3942757.html)。

一些汇编器
* gas （GNU assemble）。`/usr/bin/as`配套的的GNU ld `/usr/bin/ld`
* masm（Microsoft Macro Assembler）。一般在VS安装目录中可以找到，比如`\VisualStudio2010\VC\bin\ml.exe`和链接器`\VisualStudio2010\VC\bin\link.exe`。也可以单独安装。
* nasm（Netwide Assembler）https://www.nasm.us/
* yasm http://yasm.tortall.net/ Yasm is a complete rewrite of the NASM assembler under the “new” BSD License.

有的汇编器可以支持多种语法、多种目标平台，比如NASM。

## X86架构下寄存器
### X86
https://www.eecg.utoronto.ca/~amza/www.mindsec.com/files/x86regs.html

https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm

https://www.cs.virginia.edu/~evans/cs216/guides/x86.html

### X86-64

https://wiki.cdot.senecacollege.ca/wiki/X86_64_Register_and_Instruction_Quick_Start

## 汇编程序基本结构

参考《汇编语言：基于linux环境》第三版8.1节。

https://www.cnblogs.com/Torstan/archive/2012/07/22/2604068.html

## X86 Calling convention

参考wiki:https://en.wanweibaike.com/wiki-X86%20calling%20convention
参考：https://codearcana.com/posts/2013/05/21/a-brief-introduction-to-x86-calling-conventions.html

注意要区别与C调用公约（参见《汇编语言：基于linux环境》第三版第12章）。显然C与X86不是互相绑定的。

区别比较明显的一点是C调用公约要求被调用的过程必须保持EBX、ESP、EBP、ESI、EDI这些寄存器的值。


## X86内存模式以及寻址方式

参考《汇编语言：基于linux环境》第三版第4章以及第9.5节。

## 指令与位宽

AT&T语法中操作数的宽度由操作码的最后一个字符确定。操作码后缀有b-8位、w-16位、l-32为、q-64位。

intel语法通过在操作数前使用前缀`byte ptr`、`word ptr`、`dword ptr`、`qword ptr`来达到同样目的。

## x86部分指令

* INT 软中断

* IRET 从中断处理返回

* CALL 跳转到给定地址，同时将下一跳指令地址（返回地址）压栈，压栈同时伴随ESP寄存器的修改

* RET  将栈顶弹出到CS:IP或IP中（取决于是否跨段（是否远调用）），从而从过程返回，同时也伴随ESP寄存器的修改

* LEA  Load Effective Address

* JMP  无条件跳转，不像CALL那样有栈操作

* LEAVE 恢复上一个过程的RBP与RSP值，通常后面是ret指令，然后子过程就返回

* PUSH 压栈，同时伴随修改ESP寄存器

* PUSHA 将所有16位通用寄存器压栈  对应POPA

* PUSHAD 将所有32位通用寄存器压栈  对应POPAD

* PUSHF 将16位标志寄存器压栈  对应POPF

* PUSHFD 将32位标志寄存器压栈  对应POPFD

* POP 出栈，同时伴随ESP寄存器修改


关于上面部分指令的一个图示说明参见：https://blog.csdn.net/striver1205/article/details/25695437

## Linux-x86下使用gas汇编

[as汇编器文档](http://tigcc.ticalc.org/doc/gnuasm.html)

### 系统调用
这里的系统调用指的是通过int软中断触发的系统调用，而非是`unistd.h`中做过初步C封装的系统调用。

显然，通过int中断调用系统服务需要提供中断号以及按要求传递参数以及取得返回值。关于这些信息，
可以从[这里](https://syscalls.w3challs.com/)查获。

需要注意的是Linux下的X86与x86-64的同名系统调用其中断号与传参返回值约定是不一样的，也就是ABI不同。

然而这又无关于我们下一小节提到的在64位下编译32位程序。

首先从系统调用的[man syscall](https://www.man7.org/linux/man-pages/man2/syscall.2.html)文档中可以看到x86
与x86-64调用系统中断的指令是不同的，x86通过`int $0x80`，而x86-64通过`syscall`，注意`syscall`是x86-64原生支持的指令
，可以参见[这里](https://stackoverflow.com/questions/10583891/is-syscall-an-instruction-on-x86-64)。

所以在64位系统下编译32位程序其实无关于位数了，只要使用`int`，64位系统也按32位的ABI来。

### 在64位系统下编译32位程序

比如将`hello.s`编译为32位程序：
```
as -32 -o hello.o hello.s
ld -m elf_i386 -s -o hello hello.o
```

### gas嵌入汇编

参考《Linux内核完全剖析》2010第一版第3.3.2节。

### C与汇编的相互调用

参考《Linux内核完全剖析》2010第一版第3.4节。

参考《汇编语言：基于Linux环境》第三版第12章。

## gas cfi
https://www.imperialviolet.org/2017/01/18/cfi.html

https://blog.csdn.net/permike/article/details/41550991

### GUN二进制工具 

https://sourceware.org/binutils/

## 例子

https://www.cnblogs.com/justinzhang/archive/2012/02/20/2360513.html
