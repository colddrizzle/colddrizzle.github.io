---
layout: post
title: sicp1.1 scheme的基本语法
description: ""
category: sicp
tags: [sicp]
---
{% include JB/setup %}

## 一、scheme的基本语法
scheme的语句看起来都是一样的，看起来都遵循`(action args)`的模式。
但是这些语句可以分为两类：求值式与非求值式。区分的依据就是这些语句的解释规则不同。

### 1. 求值式
对于求值式，其可以被求值，又可以分为一般求值式与特殊求值式。一般求值式的规则就是讲参数应用于操作符。表达式语法：
```
expression: number|(expression)

expression: (op expression ...)
```
虽然上面是如此写，但是到目前为止，看起来scheme并不支持变长参数。

特殊求值式cond与if。是的，跟我们常见的c、java之类的不同，scheme中整个cond与if语句是返回一个值的。而java中是在if与cond中为变量赋值。
conf与if求值式中引入了**条件表达式**的概念。条件表达式的结果为布尔值，并引入**谓词**的概念，谓词比如`= > < >= <= and or not`。
* cond用于条件选择，语法`(cond (expression_test expression_choice)...)`。求值规整是逐一求值expression_test，若为真，则求值对应的expression_choice作为整个式子的值。
* if是只有两种选择的cond语法糖。语法`(if expression_test expression expression)`

求值式有两种解释方法：正则序与应用序。正则序将表达式中的过程逐渐代换，展开成不包含过程定义的组合表达式，对于递归的情况，正则序不一定能够完全展开。
而应用序是现将参数求值（参数也是应用序求值），然后应用于操作符。

### 2.非求值式
对于非求值式，解释规则则有具体定义，目前的非求值式有define。define用于命名，又可以分为两种。给不带形参的求值式命名如
(define x 2)
给带形参的求值式命名，也就是定义符合过程。 **scheme这里开始引入形参的概念**。比如(define (increase x) (+ x 1))。
这里的妙处在于带形参的求值式名字本身的格式也是带形参的求值式，也就是调用与定义的格式完全一致。
形参的意义如同数学中的变量，其使用方法也如同数学中的变量，当实际参数知晓时，将其在过程体中替换，称之为代换模型。代换模型不能覆盖所有的情况，当参数是变化的数据的
时候，代换模型就无能为力了。因此实际的解释器并不是先展开代换表达式，然后求值，而是通常引入一个“局部环境”的概念来达到代换模型的效果，这就是我们熟悉的局部变量。

至此，无论是求值式，还是非求值式，语法都遵循一个模式，形如`(action args)`，非常简约，因而解释器非常容易实现。

### 3.过程作为黑箱抽象

为了抽象过程，引入局部名与内部定义，然后我们就可以很自然的看到函数式编程所谓闭包的由来，以及词法作用域如何工作。


## 习题

### 练习1.5
注意本题假定了if求值式的求值规则在正则序与应用序都是先求值条件，然后根据条件求值具体分支。这意味着正则序展开的时候，其实遇到if条件是先做了运算在展开，完全展开后再运算的。
这跟上面说的正则序并不完全一致，上面的正则序最后才运算，之前都是代换。在这个前提下，应用序就会陷入求值(p)的死循环中。

### 1.1.7小节new-if问题
区别在于if表达式是特殊求值式，而new-if是一般求值式，他们的求值规则不同。对于new-if，第三个参数包含递归，先求值参数会导致递归。

上面两个习题出现递归的原因都是“先求值参数然后应用”，这也就是一般求值式的求值规则。



## 思考

区分正则序、应用序、代换模型、局部环境模型。
根据上面描述的语法，一个scheme解释器需要处理求值式与非求值式的解释规则、运行环境，局部变量或者说名字空间。

## 代换模型应用的程序实现

书中的代换模型应用过程需要我们在脑中或是用纸笔来演算，此处给出一种程序演算方法。

代换模型的应用条件有两个：
1. 应用对象是一个复合过程 
2. 给定参数的情况下
代换模型是一种具体情况具体分析的方法。

在代换模型的应用过程中，涉及几个概念：复合过程或复合求值式 ，基本过程或基本求值式。所谓基本过程是指给定了实参之后立刻就可以计算出值的过程，其计算过程不再调用其他过程。
所谓复合过程指的是用define定义的过程，包含左边与右边两部分，复合过程的右边一定调用了其他过程，如此才可以成为复合。
需要注意的是同一个操作可能在一个场景下是复合过程，在另一个场景下是基本过程。比如+操作，我们可以把它当成基本过程，也可以
认为+操作是用inc和dec定义的复合过程。

观察书中的几个例子，在代换模型的应用过程可以描述如下：
1. 用复合过程的右边替换左边
2. 遇到任何参数确定的基本过程的时候，立刻用该过程的值替换该过程
3. 遇到任何条件确定了的cond、if求值式时，则只取相应分值

那有了上述规则，我们便可以用程序来实现代换模型的应用了。在编写程序之前，需要厘清两个语言。一个是编写复合过程的scheme语言，
一个是处理shcheme语言复合过程的语言，不妨称之为**元语言**，当然这个元语言也是相对于scheme语言来说的，这有点像c语言写的cpython处理python脚本。

并且，由上面的思考可知，一个操作不能光凭名字断点是否复合操作，也就是说我们不能武断的说`(+ 4 5)`一定是基本过程从而立刻求出值，这是随场景的。
给定一个场景，很容易分析出哪些是基本过程哪些是复合过程，比如我们分析出一个场景中一个奇怪的表达式`(% 1 2)`是一个基本过程，但是单凭场景信息并不能知道该过程如何立刻求值，所以基本过程的求值过程还是需要元语言来定义的。

有了上面的分析，那我们知道需要编写的程序的输入了：
1. 一个场景，也就是包含一堆scheme语句。
2. 一个给定参数的复合过程，也就是代换模型的待应用对象
3. 一个基本过程的元语言定义

我们的程序的输出就是一步一步的代换过程。
具体一点，一个例子，元语言为python。输入为：
```
basic:(= @ #) == "@==#"
basic:(inc @) == "@+1"
basic:(dec @) == "@-1"

(define (+ a b)
	(if (= a 0)
		bs
		(inc (+ (dec a) b))))

target:(+ 4 5)
```
上面的例子中我们用basic与target标记基本过程与目标。用元语言给出基本表达式的语义，右边的双引号中的东西可以直接被动态语言中的eval之类的直接计算
为了方便替换用一些特殊符号表示形参，当然在更广泛的场景下可能会有问题，但是应付我们的几个例子足够了。

我们需要用python处理上面的输入，解析出所有的标记语句与复合过程的定义，在这里我们姑且认为这里涉及到的scheme语言过程名不包括参数，也就是(+ a b)与(+ a b c)是冲突的定义。我们还需要特殊处理define语句与if、cong语句。另外注意scheme的词法规则：任意个连续空格分隔符号。一对括号表示一个表达式。
对于(()(()))这种嵌套括号的形式，每次只识别一层就好了。

处理程序为：
```

```