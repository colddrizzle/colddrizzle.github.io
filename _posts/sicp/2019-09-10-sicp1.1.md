---
layout: post
title: sicp1.1 scheme的基本语法
description: ""
category: sicp
tags: [sicp]
---
{% include JB/setup %}

## 一、scheme的基本语法
scheme的语句看起来都是一样的，看起来都遵循`(action args)`的模式。
但是这些语句可以分为两类：求值式与非求值式。区分的依据就是这些语句的解释规则不同。

### 1. 求值式
对于求值式，其可以被求值，又可以分为一般求值式与特殊求值式。一般求值式的规则就是讲参数应用于操作符。表达式语法：
```
expression: number|(expression)

expression: (op expression ...)
```
虽然上面是如此写，但是到目前为止，看起来scheme并不支持变长参数。

特殊求值式cond与if。是的，跟我们常见的c、java之类的不同，scheme中整个cond与if语句是返回一个值的。而java中是在if与cond中为变量赋值。
conf与if求值式中引入了**条件表达式**的概念。条件表达式的结果为布尔值，并引入**谓词**的概念，谓词比如`= > < >= <= and or not`。
* cond用于条件选择，语法`(cond (expression_test expression_choice)...)`。求值规整是逐一求值expression_test，若为真，则求值对应的expression_choice作为整个式子的值。
* if是只有两种选择的cond语法糖。语法`(if expression_test expression expression)`

求值式有两种解释方法：正则序与应用序。正则序将表达式中的过程逐渐代换，展开成不包含过程定义的组合表达式，对于递归的情况，正则序不一定能够完全展开。
而应用序是现将参数求值（参数也是应用序求值），然后应用于操作符。

### 2.非求值式
对于非求值式，解释规则则有具体定义，目前的非求值式有define。define用于命名，又可以分为两种。给不带形参的求值式命名如
(define x 2)
给带形参的求值式命名，也就是定义符合过程。 **scheme这里开始引入形参的概念**。比如(define (increase x) (+ x 1))。
这里的妙处在于带形参的求值式名字本身的格式也是带形参的求值式，也就是调用与定义的格式完全一致。
形参的意义如同数学中的变量，其使用方法也如同数学中的变量，当实际参数知晓时，将其在过程体中替换，称之为代换模型。代换模型不能覆盖所有的情况，当参数是变化的数据的
时候，代换模型就无能为力了。因此实际的解释器并不是先展开代换表达式，然后求值，而是通常引入一个“局部环境”的概念来达到代换模型的效果，这就是我们熟悉的局部变量。

至此，无论是求值式，还是非求值式，语法都遵循一个模式，形如`(action args)`，非常简约，因而解释器非常容易实现。

### 3.过程作为黑箱抽象

为了抽象过程，引入局部名与内部定义，然后我们就可以很自然的看到函数式编程所谓闭包的由来，以及词法作用域如何工作。


## 习题

### 练习1.5
注意本题假定了if求值式的求值规则在正则序与应用序都是先求值条件，然后根据条件求值具体分支。这意味着正则序展开的时候，其实遇到if条件是先做了运算在展开，完全展开后再运算的。
这跟上面说的正则序并不完全一致，上面的正则序最后才运算，之前都是代换。在这个前提下，应用序就会陷入求值(p)的死循环中。

### 1.1.7小节new-if问题
区别在于if表达式是特殊求值式，而new-if是一般求值式，他们的求值规则不同。对于new-if，第三个参数包含递归，先求值参数会导致递归。

上面两个习题出现递归的原因都是“先求值参数然后应用”，这也就是一般求值式的求值规则。



## 思考

区分正则序、应用序、代换模型、局部环境模型。
根据上面描述的语法，一个scheme解释器需要处理求值式与非求值式的解释规则、运行环境，局部变量或者说名字空间。
