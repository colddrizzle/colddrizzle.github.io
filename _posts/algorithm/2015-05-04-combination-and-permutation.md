
# 组合生成算法

## 递推法
生成m选n组合的思路一：
m选n组合可以看做是m选（n-1）组合上的每一组上再加一个元素

但是要如何保证再加一个不会产生重复的组合呢？

我们来考察一个元素的组合生成两个元素组合的过程：

比如集合[1, 2, 3, 4, 5]，一个元素的组合就是各个元素自己。

再加上一个元素：
首先1，那么能加2、3、4、5产生四个组合：
（1、2） （1、3）（1、4）（1、5）

其次2， 那么能加1、3、4、5，我们看到2加上比自己小的一个数生成的组合是重复的。
因此只能是加3、4、5产生3个组合。
（2、3）（2、4）（2、5）

依次类推，3产生2个组合：
（3、4）（3、5）

4产生一个组合：
（4、5）

5无法生成新组合。


现在我们考察2个元素的组合生成3个元素组合的过程。


可以发现规律似乎是要加一个比当前组合内最大元素还要大的元素。

我们来证明这是对的。

证明思路很简单：m选n的组合数利用公式可以算出来。
我们只需要证明上述算法产生的m选n组合各不相同，且总数与m选n的组合数相等就可以了。

从字典序的角度来考虑，将所有的2个元素的组按如下排列：
```
（1、2） （1、3）（1、4）（1、5）（2、3）（2、4）（2、5）（3、4）（3、5）（4、5）
```


## 字典序

不失一般性地，设集合m个元素分别为[1, 2, ..., m]。
从m中任选n个元素，对于选定的一组n个元素，考虑其组合，因而需要排除这n个元素调换顺序的情况。为此，
我们定义n个元素按其数值递增排列的组合为规范组合。比如5选3，[1, 2, 3]是规范组合，[1, 3, 2]不是规范组合，
我们用规范组合来唯一地表示一组组合。

既然规范组合有了唯一顺序，那么我们可以用字典序来比较两个规范组合，比如[2, 3, 4]大于[1, 2, 4]，小于[2, 3, 5]。

既然定义了字典序，我们自然可以按照字典序枚举出各个组合。依旧是[1, 2, 3, 4, 5]中选3个。那么最小的自然是[1, 2, 3]。

则规范组合的枚举如下：

```
[1, 2, 3] [1, 2, 4] [1, 2, 5]

此时最后一位5最大，则前一位进1，得到[1, 3, ?]。

关键进1位之后最后一位的起始值是多少？

注意规范组合的各位数字严格递增，因此[1, 3]开头的最小的规范组合只能是[1, 3, 4]。继续枚举如下：

[1, 3, 4] [1, 3, 5]

[1, 4, 5]

[2, 3, 4] [2, 3, 5]

[2, 4, 5]

[3, 4, 5]

```

按照上述的分析，算法如下：

首先需要一个变量记录当前递增的位
还需要一个变量记录递增的值

然后需要一个变量记录递增的最大值


```brush:python

def combination(m, n):
	l_m = list(range(m))

	l_p = list(range(n))

	s = n-1
	e = n-1
	c = n-1

	
```


# 排列生成算法

https://baike.baidu.com/item/%E4%B8%AD%E4%BB%8B%E6%95%B0/12796689?fr=aladdin

https://blog.csdn.net/zh_94/article/details/81416263

https://www.cnblogs.com/xiongmao-cpp/p/4996230.html