---
layout: post
title: 最大连续子序列问题
description: ""
category: 算法
tags: [算法,动态规划]
---
{% include JB/setup %}

## 问题描述
给定一个只包含数字的有序序列，求该数组中加和最大的连续子序列起止位置以及和。当然，序列中包含负数。

## 问题分析
拿到这个问题的第一直觉是分析子问题然后做DP。一般这种序列问题拆分子问题的方法有些套路可循，设序列为$$X_i=[x_1,x_2,x_3...X_i], $$常见的拆法：
* 从子序列对应到子问题
	* 寻找$$X_i与X_{i-1}$$之间的关系
	* 任意子序列的任意拆分成两部分。寻找$$[x_i...x_j]$$拆分成$$[x_i...x_k]与[x_{k+1}...K_j]$$之间的关系
* 从子问题对应到子序列
    * 子问题增加、缩短1
    * 子问题中间拆分为两部分

拆的过程中还需要注意有些需要先做问题转换。本题就是先做问题转换，再来拆分子问题为递增子序列的方法来找到递归解的。问题是求整个序列的最大连续子序列，
首先转换为以某个位置为结尾的最大连续子序列。下面是该问题的完整分析以及实现。

首先，该问题有一个需要注意的地方：可能存在多个相同的最大子序列，比如
* [1,2,3,-10,3,3]     [1,2,3]与[3,3]都是最大连续子序列
* [1,2,3,-6,7]  [1,2,3,-6,7]与[7]都是最大子序列

其次我们可以注意到这样一个事实：若$$[x_i...x_j]$$是$$[x_1....x_n]$$的最大连续子序列，则$$[x_i...x_j]$$必然是原序列中以
$$x_j$$结尾的最大连续子序列，令其为E(j)。因此，我们只需要计算出所有的E(i)，其中i=1,2,3...n， 然后找到最大的E(i
)就可以了。

然后我们看怎么计算E(i)，很简单，就是从$$x_i$$开始往前加，最大的和就是E(i)，和最大的时候也就是子序列的起始下标，注意这个下标可能有多个。
我们看怎么简化计算E(i)，基本思路就是寻找E(i)与E(i-1)的关系。很容易用反证法证明$$E(i+1)=max(E(i)+x_{i+1}, x_{i+1})$$，或者可以直观的观察到
这样的关系：E(i)的所有计算过程是在E(i-1)的所有计算过程上加上$$x_i$$之后获得的，如下图：
```
[x1,x2,x3,x4]

E(3):              E(4):
                            x4  --> x4
      x3                 x3 x4 |
   x2 x3              x2 x3 x4 |--> E(3) + x4
x1 x2 x3           x1 x2 x3 x4 |

```

因此我们只需要一遍遍历就能计算出所有的E(i)，同时找出最大的E(i)。
仅求和的情况下，空间消耗为O(n)，时间消耗为O(n)。

为了简化编码，下面仅计算出最大和，不求起止位置。

<pre class="brush:python;">
# coding=utf-8


def max_continued_sub_sequence(seq):
    L = len(seq)
    # 只求和其实不需要记录E数组，只需要记录上一个E
    # 我们为了方便debug而记录整个E数组
    E = [0] * (L+1)  # 为了方便处理首位补一个负无穷 
    E[0] = -float('inf')

    m = -float('inf')
    for i in xrange(1, L+1):
        E[i] = max(E[i - 1] + seq[i-1], seq[i-1])
        m = max(E[i], m)

    return m


if __name__ == "__main__":
    print max_continued_sub_sequence([4, 5, -1, 7, 8])  # 23
    print max_continued_sub_sequence([1, 2, 3, -10, 3, 3])  # 6
    print max_continued_sub_sequence([1, 2, 3, -6, 7])  # 7
    print max_continued_sub_sequence([7, -7])  # 7

</pre>

