---
layout: post
category : 算法
tagline: "Supporting tagline"
tags : [算法导论, 编辑距离, 动态规划]
title: 从编辑距离问题谈动态规划
---
{% include JB/setup %}

编辑距离是一个非常有实际意义的问题，常见的实际应用有搜索引擎中中输入提示的实现，生物科学中比较两段DNA的相近程度。
本题题干采用《算法导论》动态规划章节的课后习题-编辑距离，不再赘述。

***************

## 为何可采用动态规划？
动态规划的适用条件有其一般的说法，具体见[这儿][0],在此我试着换一种说法来表述其适用条件。
#### 问题具有同构子问题
同构子问题，指的是问题的规模可以缩小的同时保持其余特性不变，而不是指问题可以分成若干部分从而可以各个击破。这里的子问题更像俄罗斯套娃，而不是乐高积木。
比如两点最短路径问题，可以转换为终点的前导节点与起点之间的最短路径问题。路径的长度减少了，然而问题仍是两点之间最短路径问题，只不过是多个“更小的”最短路径问题。
#### 问题的直接子问题空间有限
子问题空间有限其实暗含子问题规模不是可以任意缩小的，规模的缩小是离散的，而不是连续的。有限意味着在有限时间内可以遍历子问题空间，一般情况下还要求子问题空间较小，否则该问题也可能不适用于动态规划。
#### 问题的最优解一定可以且仅仅依靠其直接子问题的最优解确定
旅行商问题有同构子问题且子问题空间有限，然而却不能用动态规划来解答，这是因为其子问题的解对于解决父问题毫无帮助。
#### 子问题重叠
子问题重叠才使得动态规划优化运行时间成为可能。每一级的子问题空间有限且较小，再加上不同的子问题空间之间存在重叠部分，导致搜索总的解空间时间通常是可以接受的。
动态规划其实是分治法的特殊情况，特殊就特殊在动态规划适应的问题其子问题空间是重叠的。

综上四个方面，才使得问题能够使用动态规划来解答。
## 分析策略
令两个字符串分别为为A[1...m],B[1...n]，以下分析都使用此处定义的符号。
对应到编辑距离的问题，首先编辑距离问题有同构子问题：两个字符串A[1...m]与B[1...n]之间的编辑距离显然可以缩小为A[1...s]与B[1...t](1<s<m,1<t<n)之间的编辑距离问题。其次，编辑距离的问题的直接子问题空间有限且很小，
显然由字符串A[1...s]与B[1...t]转换到A[1...m]与B[1...n]只有通过题目中的六种确定的编辑方法。由于“消灭”对应不止一个子问题，分析后可得，直接子问题空间大小最多仅仅为O(m)。其三，若我们获得了其直接子问题空间的最优解，那么遍历其直接子问题空间显然一定可以
得到其直接上层问题的最优解，这可以通过反证法来证明，证明很简单，此处略去。最后，子问题空间重叠。为方便叙述，我们使用具体数字来代替字母m,n,s,t。如问题A[1...5],B[1...6]的直接子问题包括:A[1...4]和B[1...5]（复制），A[1...5]和B[1...5]（插入），
A[1...4]和B[1...6]（删除），A[1...4]和B[1...5]（替换）,A[1..3]和B[1...4]（交换），A[1...i]和B[1...6]（消灭，其中1<i<5）。显然问题A[1...3],B[1...5]的直接子问题包括:A[1...3]和B[1...4]（插入）与问题A[1..5]，B[1..6]的子问题空间重叠。

这里要注意的是“消灭”操作。“消灭”操作若有则一定是最后一步操作，因此中间的子问题空间不会涉及到这一步，其子问题空间仅仅为5，因此“消灭”操作可以放在最后来做。
在此，总结下动态规划问题的分析技巧。
当我们拿到一个问题，直觉上感觉其有同构子问题可以用动态规划来做的时候，可以尝试以下步骤。
#### 从最后最优结果开始
一般的动态规划问题的阶段性都很明显，分析是倒着进行的。可以先假定一个最优结果，猜测其直接子问题空间，然后分析直接子问题的最优解如何转换为最终结果
的最优解，这个转换方法若能找到，基本就能写出递归式了。
#### 至最初状态结束
上诉逆推的过程最终是要来到初始状态的，初始状态的子问题空间的最优解通常可以简单计算确定，比如编辑距离的初始状态便是当至少一个字符串长度为0的时候。
#### 明确*状态*的含义
有的动态规划问题的状态并不明确，状态的定义也比较晦涩，如最长升序子序列问题：数字列D[1...n]的最优子问题并不是数字列D[1...n-1]的的最长升序子序列，而是以
第n-1个数字结尾的最长升序子序列问题。划分阶段，寻找状态通常需要转换问题，需要一定的经验和灵感。
## 递归定义
综上所述，很容易给出编辑距离问题的递归式。
![递归式][1]

初始化如下：   
opt[i][0]=min(i·cost(delete),cost(kill)), 0<i<m   
opt[0][j]=j·cost(insert), 0<j<n

## 程序实现

<pre class="brush:python;">    
    A="gabdeffff"
    B="abde"
    costs={'copy':1,
           'replace':1,
           'insert':1,
           'delete':1,
           'exchange':2,
           'kill':3}
    opt=[[0]*20 for i in range(20)]

    #初始化
    for i in range(1,len(A)+1):
        opt[i][0]=min(i*costs['delete'],costs['kill'])
    for j in range(1,len(B)+1):
        opt[0][j]=j*costs['insert']

    for i in range(1,len(A)+1):
        for j in range(1,len(B)+1):
            iA=i-1
            jB=j-1
            
            exchange=float('inf')
            if iA-1>=0 and jB-1>=0 and A[iA-1]==B[jB] and A[iA]==B[jB-1]:
                exchange=opt[i-2][j-2]+costs['exchange']
            copy=float('inf')
            if A[iA]==B[jB]:
                copy=opt[i-1][j-1]+costs['copy']
            replace=opt[i-1][j-1]+costs['replace']
            insert=opt[i][j-1]+costs['insert']
            delete=opt[i-1][j]+costs['delete']
            opt[i][j]=min(exchange,copy,replace,insert,delete)

    min_cost=min(opt[len(A)][len(B)],min([opt[i][len(B)]+costs['kill'] for i in range(len(A))]))
    print min_cost
</pre>

## 找出所有的最短编辑路径
递归或者用一个栈便可以遍历所有的路径，唯一的难处是若之前未能存储规划表中的每一格的后继，便需要重新计算：

## 推荐参考资料
*   [动态规划 by starfish][2]
*   [通过金矿模型介绍动态规划][3]

[0]:http://iprai.hust.edu.cn/icl2002/algorithm/algorithm/technique/dynamic_programming/chapter3.htm
[1]:/assets/resources/2.png
[2]:http://iprai.hust.edu.cn/icl2002/algorithm/algorithm/technique/dynamic_programming/index.htm
[3]:http://www.cnblogs.com/sdjl/articles/1274312.html
