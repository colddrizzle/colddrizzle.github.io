---
layout: post
category : 算法
tagline: "Supporting tagline"
tags : [算法导论, 编辑距离, 动态规划]
title: 从编辑距离问题谈动态规划
---
{% include JB/setup %}

编辑距离是一个非常有实际意义的问题，常见的实际应用有搜索引擎中中输入提示的实现，生物科学中比较两段DNA的相近程度。
本题题干采用《算法导论》动态规划章节的课后习题-编辑距离，不再赘述。
***************
##为何可采用动态规划？
动态规划的适用条件有其一般的说法，具体见[这儿][0],在此我试着换一种说法来表述其适用条件。
####问题具有同构子问题
同构子问题，指的是问题的规模可以缩小的同时保持其余特性不变，而不是指问题可以分成若干部分从而可以各个击破。这里的子问题更像俄罗斯套娃，而不是乐高积木。
比如两点最短路径问题，可以转换为终点的前导节点与起点之间的最短路径问题。路径的长度减少了，然而问题仍是两点之间最短路径问题，只不过是多个“更小的”最短路径问题。
####问题的直接子问题空间有限
子问题空间有限其实暗含子问题规模不是可以任意缩小的，规模的缩小是离散的，而不是连续的。有限意味着在有限时间内可以遍历子问题空间，一般情况下还要求子问题空间较小，否则该问题也可能不适用于动态规划。
####问题的最优解一定可以且仅仅依靠其直接子问题的最优解确定
旅行商问题有同构子问题且子问题空间有限，然而却不能用动态规划来解答，这是因为其子问题的解对于解决父问题毫无帮助。
####子问题重叠
子问题重叠才使得动态规划优化运行时间成为可能。每一级的子问题空间有限且较小，再加上不同的子问题空间之间存在重叠部分，导致搜索总的解空间时间通常是可以接受的。
动态规划其实是分治法的特殊情况，特殊就特殊在动态规划适应的问题其子问题空间是重叠的。

综上四个方面，才使得问题能够使用动态规划来解答。
##分析策略
令两个字符串分别为为A[1...m],B[1...n]，以下分析都使用此处定义的符号。
对应到编辑距离的问题，首先编辑距离问题有同构子问题：两个字符串A[1...m]与B[1...n]之间的编辑距离显然可以缩小为A[1...s]与B[1...t](1<s<m,1<t<n)之间的编辑距离问题。其次，编辑距离的问题的直接子问题空间有限且很小，
显然由字符串A[1...s]与B[1...t]转换到A[1...m]与B[1...n]只有通过题目中的六种确定的编辑方法。由于“消灭”对应不止一个子问题，分析后可得，直接子问题空间大小最多仅仅为O(m)。其三，若我们获得了其直接子问题空间的最优解，那么遍历其直接子问题空间显然一定可以
得到其直接上层问题的最优解，这可以通过反证法来证明，证明很简单，此处略去。最后，子问题空间重叠。为方便叙述，我们使用具体数字来代替字母m,n,s,t。如问题A[1...5],B[1...6]的直接子问题包括:A[1...4]和B[1...5]（复制），A[1...5]和B[1...5]（插入），
A[1...4]和B[1...6]（删除），A[1...4]和B[1...5]（替换）,A[1..3]和B[1...4]（交换），A[1...i]和B[1...6]（消灭，其中1<i<5）。显然问题A[1...3],B[1...5]的直接子问题包括:A[1...3]和B[1...4]（插入）与问题A[1..5]，B[1..6]的子问题空间重叠。

这里要注意的是“消灭”操作。“消灭”操作若有则一定是最后一步操作，因此中间的子问题空间不会涉及到这一步，其子问题空间仅仅为5，因此“消灭”操作可以放在最后来做。
在此，总结下动态规划问题的分析技巧。
####从最后最优结果开始
####至最初状态结束
####明确*状态*的含义
##递归定义
综上所述，很容易给出编辑距离问题的递归式。
![递归式][1]

初始化如下：
opt[i][0]=min(i*cost(delete),cost(kill)), 0<i<m   
opt[0][j]=j*cost(insert), 0<j<n

##程序实现
<input type="hidden" class="brush" value="brush:python;" />
    
    def foo:()
        pass

##找出所有的最短编辑路径

[0]:http://iprai.hust.edu.cn/icl2002/algorithm/algorithm/technique/dynamic_programming/chapter3.htm
[1]:/assets/resources/2.png