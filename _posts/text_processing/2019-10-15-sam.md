本文依托于：
https://www.cnblogs.com/zjp-shadow/p/9218214.html
或
https://hihocoder.com/problemset/problem/1441
。
但看另外两篇文章之前先看这篇文章热身最好。

后缀自动机可以处理的问题有很多，但自动机本身是将一个
字符串的所有子串构造成自动机的形式。

之所以说是**后缀**自动机，是因为其组织子串的方式而言。

我们从头说起，考虑一个字符串匹配问题：字符串s1是否为s2的子串，当然s2的长度不短于s1的长度。
那么最最最最最朴素的想法，把s2的所有的子串全部列出来，然后把所有的子串组织成trie树。

那怎么样列出所有的子串呢？最自然的想法是先列出长度为1的，再列出长度为2的，依次类推。

```
原串:  aabbabd
len=1: a a b b a b d
len=2: aa ab bb ba ab bd
len=3: aab abb bba bab abd
len=4: aabb abba bbab babd
len=5: aabba abbab bbabd
len=6: aabbabd

```
然后将其组织成tire树。


显然不同的子串直接有共同前缀，而trie树则利用了这部分前缀，减少了存储空间，比如子串aa与aab。然后子串内部的重复现象并没有利用到，比如子串aab里a重复，abbab里ab重复。

而后缀自动机列出所有子串的方式并不一样。假设长度为n的字符串s[1...n]的后缀集合为suffix(s)。
那么长度为n的字符串S[1...n]的所有子串是suffix(S[1])+suffix(S[1,2])+..+suffix(S[1...n])。

证明方式很简单。上面按照长度切分划出的子串肯定是字符串s的所有子串，其总数为`(1+n)*n/2`。
而按后缀集合拆分出s的所有子串的方式中，任意两个集合必然不想交（不同位置的子串认为是不同的子串，比如aba中a子串有两个）。
但他们的总数也是(1+n)n/2。所以这个子串集合必然也是字符串s的全部子串。

按照这种拆分方式，上面的例子按后缀拆成子串应该是：

```



```