---
layout: post
title: 论文翻译：java内存模型
description: ""
category: java
tags: [jmm]
---
{% include JB/setup %}

* toc
{:toc}


<hr />
本文是论文-The Java Memory Model∗的翻译。

## Abstract

这篇论文描述了Java 5.0修订的新的java内存模型。该模型规范了多线程程序的合法行为，定义了多线程程序的语义，部分地决定了java虚拟机与编译器的合法实现。

新的java内存模型给正确同步的程序提供了一个简单的接口：也就是对Data-race-free的程序保证了顺序一致性。该模型新颖之处在于它用一个定义完好的因果概念限定了非正确同步程序的行为。这个因果性要求足够强壮能满足java安全性的要求，并且足够的弱能满足标准的编译器与硬件的优化要求。据我们所知，其他模型要么太弱无法满足java安全性的要求，要么太强因为依赖于一个“数据与控制依赖”的概念，该概念阻止了一些标准的编译器变形（编译器转化就是讲程序做某种修改使得性能更优但结果一致）。

虽然当前编译器中大部分行为是合法的，新模型引入了明显的改进，清晰定义合法转化的边界。例如，普遍接受的控制依赖定义对于java是错误的，基于此的转化可能是无效的。

除了给java提供正式的内存模型，我们相信该模型能给其他缺少完善定义的语言提供非常有用的帮助，比如C++与C#。

目录和主题：
* D.3.1 [Programming Languages]:形式化定义与理论。
* D.3.0 [Programming Languages]: 标准。
* F.3.2 [Logics and Meanings of Programs]: 操作语义

## 1.Introduction

多线程系统的内存模型给程序员规范了程序执行时内存操作（比如 读与写）的表现，特别地，读某一个地址的每一次读应该返回哪个值。每一个通过允许多线程访问共享的内存的
系统的硬件与软件接口都需要一个内存模型。该模型决定系统（编译器、虚拟机、硬件）能给在该接口之上编写的程序应用的变形。例如，给定一个机器语言上的程序，
该机器语言与硬件之间的接口会决定硬件能够应用的优化。

对于一个高级编程语言比如java来说，该内存模型决定了编译器将程序转化为字节码的时候能够应用的变形、虚拟机将字节码转为机器码的时候能够应用的变形，以及硬件执行
机器码时能应用的优化。

模型同样影响程序员；模型允许或禁止的变形决定了程序的可能结果，该结果有决定了线程之间哪一种通信模式是合法的。如果变成语言没有一个完好定义的内存模型，不可能知道该语言程序的合法结果。例如，为了决定某种语言下Double Checked Locking以及其变种是有效的，需要一个内存模型。（还有lamport顺序一致性中的那个互斥算法）

### 1.1 Background

在过去20年里，在硬件接口层面有大量关于内存模型的研究成果[2,3,4,12,14,17,31,40,43]，但很少有在语言层面的。编程语言层面有两个不曾在硬件层面出现的两个挑战。第一，许多编程语言比如java
有很强的安全性要求必须被遵守。第二，编译器分析以及给程序变形的能力没有限制，而硬件系统倾向于在一个限定的范围内应用优化。

先前的工作[33,34]表明java多线程程序的原来的语义有很多严重的问题。为了定位这些问题，最近java内存模型正在进行一次较大的修订。现在的新模型
提供更大的实现上的灵活性，什么是正确程序的一个清晰概念，以及正确以及错误程序的清晰语义。除此之外，新模型很大程度上与先前的好的编程实践以及JVM实现和硬件一致。

内存模型必须在程序员的易于使用性和系统设计者实现灵活性之间取得一个平衡。最容易理解的内存模型-顺序一致性模型，规定了内存动作必须以一个单一的全局顺序依次执行；任何一个线程的内存操作在全局顺序与线程程序顺序之间必须一致，称为program order。

高级语言中顺序一致性模型是否是一个合适的模型值得讨论：对于程序员来说在此模型上很容易不使用同步构建微妙复杂的并行算法。然而不幸的是，这种算法经常是设计或实现上错误的，有人声称几乎所有的程序员在编写精妙复杂的无同步的并行算法中都会受挫。

最近，硬件设计者发展出了一些技术来打破顺序一致性的限制-通过推测来重排序访问。这种重排序技术只有在对程序员不可见的情况下会使用。用来决定什么时候可以安全重排序的编译器技术也被提出来了，但仍没有在商业的编译器中完整的应用。

打破顺序一致性限制的统称方法是使用relaxed memory model，这些模型允许更多的优化。这些模型中很多来自于硬件优化工作，使用的系统低级层面的术语比如buffer与cache。通常这些模型很难去推理程序的执行顺序，并且限制了充分地实现灵活性。

为了能够实现程序简单与实现灵活，一类被称为data-race-free的模型被提出来了。这种方法应用了一种被称为正确同步的好的编程实践。data race通常是bug的信号。data-race-free模型形式化了data-race-free程序的正确性，保证了这种程序的顺序一致性。为了实现完全的灵活性，这种方法对包含data race的程序没有提供任何保证。这种方法允许标准的硬件与编译器优化，同时提供了一个简单的编程模型。

### 1.2 The Java Memory Model

新的java内存模型下，编写正确的程序需要用data-race-free方法，并保证了这种程序的顺序一致性。不幸的是，如果一个模型认为错误程序的语义
是未定义的，那就违反了java语言的安全性要求。

本次修订中一个关键贡献在于java的安全性要求禁止一类之前违背提及的包含data race的执行。挑战在于识别并且禁止这类执行同时允许标准的编译器与
硬件变形、避免模型复杂化。在先前的relaxed model中，这种执行要么是允许的，要么通过强制实行传统的控制与数据依赖来禁止。我们的工作表明后一种方法限制了标准的编译器优化，
对java来说是不切实际的。

修订的java模型是基于一种新技术。这种技术迭代的构建起合法的执行序列，在每一次迭代中，提交（commits）一组内存操作；一个内存操作只有在出现在一些well-behaved execution中的时候才会被提交，这种well-behaved execution包含先前迭代中提交的内存操作。well-behaved executions的精心定义保证了某种执行被禁止，标准的编译器变形被允许。据我们所知，这是唯一一个有这种特性的模型。

这篇论文专注于java内存模型中普通的读写、锁、volatile变量的语义，也涵盖了外部交流用的内存语义以及无限执行。篇幅原因，我们省去了java内存模型中final与finalization/garbage回收有关的内容。

## 2. Requirements For The Java Memory Model

我们主要的设计目标是在下面两者中提供一种平衡：（1）使用起来足够容易（2）当前编译器和硬件应用的变形与优化。

鉴于当前的硬件与编译器应用的变形违反了顺序一致性。当下不可能给java提供一个顺序一致性的模型（要考虑兼容性）。java内存模型因此是一个relaxed model。

java内容模型的要求与进化的详细描述可以在[30]处被找到。这里我们提供一个简要的版本。

### 2.1 Correctly Synchronized Programs

对于程序员来说，推理特定硬件与编译器的变形是很困难的。为了便于使用，我们因此定义了模型，这样程序员就不需要推理特定硬件与编译器的优化，甚至不需要知道
正确同步代码的形式化语义。我们遵循data-race-free方法定义了一个正确同步的程序（data-race-free）和这种程序的正确语义（顺序一致性）。下面的定义形式化了这些概念。

* Conflicting Accesses：对一个变量的读或者写是对这个变量的访问。对同一个共享的内存位置两个访问被称为conflicting的，如果这两个访问中至少有一个是写操作。

* Synchronization Actions：同步操作 包括 加锁、解锁、读写volatile变量。

* Synchronization Order： 程序的每一次执行都与一个同步顺序（synchronization order）关联，这个顺序是一个所有同步动作的全局顺序（且可能有多种正确的全局顺序）。为了正确的定义data-race-free程序，
我们只考虑与程序顺序（program order）一致的那些全局顺序，并且对一个volatile变量的读操作返回全局的同步顺序中该读操作之前的最后一个写操作写入的值。同步顺序的后一个要求在余下的文中明确规定为同步顺序的一致性要求。

* Synchronizes-With Order：对于两个操作x与y，我们用$$x\rightarrow_{sw} y$$表示x Synchronizes-with y。管程m上的解锁操作 synchronizes-with 随后的其他线程对管程m的所有加锁操作，其中“随后”通过synchronization-order来定义。类似地，对一个volatile变量v的写操作 synchronizes-with 随后的其他任何线程对变量v的读操作。（就好像存在一个明确的边界）。java中还有此处未讨论的其他的synchronized 边界。（注意 synchronization order是一个全局顺序，而
synchronizes-with order是某一个同步动作的顺序）。

* Happens-Before Order：对于两个操作x与y，我们使用$$ x \rightarrow_{hb} y$$表示 x happens-before y。happens-before是程序顺序与synchronizes-with顺序的
传递闭包。

* Data-Race：如果来自不同线程的两个访问x与y冲突并且之间没有happens-before关系，则称之为data-race。

* Correctly Synchronized or Data-Race-Free Program：一个程序被称为正确同步的或者data-race-free的，当且仅当这个程序的所有的顺序一致的执行都是data-race-free的。（注意这里
顺序一致性的未必是没有数据竞争的，也就是正确同步的程序要比顺序一致性要严格，且注意这个顺序一致性的执行顺序是程序员想象的，如果想象中该程序的任何一个顺序一致性执行中
都不包含数据竞争，java内存模型就能保证这种想象执行顺序下的结果成为真实的）

java内存模型的第一个要求是确保正确同步的程序的顺序一致性。程序员就只需要关心包含数据竞争的程序变形对程序结果的影响。

作为一个例子，图1中的代码是错误同步的。这个代码任何一种顺序一致的执行都包含x与y的访问冲突，并且冲突没有被happens-before关系排序。该程序的一种正确同步方法是
将x与y声明为volatile变量，那么java内存模型就保证了这个程序顺序一致性的结果。

![img](/assets/resources/jmm-0.png)

### 2.2 Out-of-Thin-Air Guarantees for Incorrect Programs

这次修订工作中的大部分，也是我们这篇文章的焦点，在于理解错误同步代码的要求。之前的讲这种错误程序的语义归为未定义的策略与java安全性保证是冲突的。这种策略先前在一些语言中
已经被使用。例如，Ada简单将未同步的代码归为“erroneous”。策略背后的思想是既然这种代码是错误的，那么就不应该给出任何保证。这就像某些语言对于数组越界的策略一样，结果是未定义的并且程序员有责任避免这样的情况。

上面的方法无助于编写正确且安全的代码。在理想世界中，程序员永远编写正确的代码。现实中，程序经常出错，这不仅使得程序行为出错，还允许攻击者破坏程序的安全假设。我们之前有工作描述这种情况的危险性[28]。

程序语义必须被完全的定义：如果程序员不知道他们代码做什么，他们也不会知道代码是怎么做错的。java内存模型另一个要求是给出错误编写（包括没有正确同步的代码）的代码的清晰明确定义的语义，同时尽量避免影响当前的编译器与硬件。

图2包含一个常见的需要明确语义的程序例子。该程序没有正确同步，该程序的所有的顺序一致执行都表现出数据竞争。然而，我们需要提供一个强的保证：寄存器r1与r2不会变成诸如42这样凭空出现的值。

![img](/assets/resources/jmm=1.png)

当前没有优化允许这样一个凭空出现的结果。然而，在将来可能出现的“精明”的系统中，线程1可能推测出42写入y，这会允许线程2读到y的值为42并将其赋给x，这又会允许线程读到x为42，并判断原来的对y的推测为42是正确的。这种自我判断写推测可能会造成严重的安全隐患，需要被禁止。例如，如果这个凭空出现的值是一个线程不该用的对象的引用，这就会造成严重的安全问题。


精确的描述出out-of-thin-air violation的构成是很困难的。并非所有的自我证明的推测都是违反安全的，其中一些甚至了导致当前编译器的变形优化。我们怎么描述一个合适的违规（violations）集合是新的java内存模型的核心，4.2节将会讨论这一点。

(以上的内容对于我们程序员理解java模型已经足够了，特别是2.1节那些概念把握好及足够了，后面的内容不是面向程序员的，暂略)

## 3. Happens-Before memory model

略






























