---
layout: post
category : python
tagline: "Supporting tagline"
tags : [python, cpython]
title: 漫谈python对象世界观
---
{% include JB/setup %}

稍微了解一点古代哲学历史的人都知道，古代哲学家曾经提出各种各样的理论来解释
世界的本源，在他们的理论架构下，世界上一切都将会得到“解释”。这是一种宏大而系统的思考方式，只有那些极具智慧且有强烈好奇心的人才会进行这种思考，他们希望通过这种思考从而能看清整个世界。

那么假如有一个哲学家--A Real Man--生活python的世界中，面对python里形形色色的对象，他会做何种思考呢，从而建立起何种世界观呢？

本文试着从旁观角度来领会哲学家的思想漫游。

--------------------------------------------------------------------
### 观察与总结

面对着各种各样的对象，恐怕哲学家首先会抛出这几个问题：
  1. 它们是什么？
  2. 它们有什么区别联系？
  3. 它们从哪里来？

我们聪明又勤奋的哲学家通过长期枯燥的观察发现，它们本质上都是某种“存在”，这些存在有一些固有的“属性”和“方法”(我们是全知的旁观角度，不去纠结哲学家自己如何给这些属性与方法存在本身命名)。这些“属性”与“方法”本身也是“存在”。
其中一些“存在”的仅有较小的区别，它们的属性与方法有相同的名字而实质却又不同，但都是由另外一个“存在”所创建的。另外一些存在则区别更大，有不同名字的的属性与方法，创建它们的“存在”也不同。
所有的“存在”都有一个`__call__`方法，但只有一部分“存在”的`__call__`方法能执行。
其中有一类“存在”的`__call__`方法总是接受一些参数，返回一个对象。这类“存在”负责创建同类型的对象，哲学家由此猜想所有的对象都是由这种类型的对象创建的。同时这种类型对象在创建其他对象的时候，会参考其他类型对象的创建过程，哲学家把这个过程称之为“继承”。

我们聪明又务实的哲学家很快给这些“存在”起了名字并分类，总结出来了自己的世界观:
  1. 这个世界是由各种“存在”构成的，这些“存在”称之为对象
  2. 具有相同名字属性与方法的对象构成一个类型 世界上有很多类型
  3. 同类型的对象都由一种类型对象创建
  4. 类型创建对象是通过对类型执行`()`操作完成的 执行`()`操作相当于执行`__call__`方法
  4. 类型本身也是对象 是一种“特殊”的对象
  5. 类型之间可以继承 但是继承不是创建类型的方法，而是创建类型时的比照模板

### 符号化与完美理论

聪明又严谨的哲学家发明了一套符号来精准的表述自己的世界观：
1. a,b,c...表示对象，a.x表示访问a的属性对象x，a.f()表示调用a的方法对象f
2. b=type_from(a)表示创建a的类型对象 b通过b()或`b.__call__()`创建对象，本质是访问b的`__call__`方法对象，并且对这个方法对象执行`()`操作
3. 若a是类型对象，type_create(a)表示是a本身代表的类型，但无歧义的情况下可以简单记为a
4. objects(a)表示类型a创建的对象
5. b = super(a)表示类型a继承自类型b，并且用super^2表示b=super(super(a))，以此类推
6. 当b = super^n(a)，称 a = subclass(b)
7. 若存在最小的m与最小的n使得c = super^m(a) 且 c = super^n(b)，则称a、b有共同的祖先，记为 c=ancestor(a, b)

并且总结出如下不言自明的公理：
1. 若存在类型对象a，则存在a的实例objects(a)，反之若存在a，则存在type_from(a)
2. 创建a类型的对象等价于a()，a()等价于`a.__call__()`
3. 如果 a 属于 objects(b) 当且仅当 type_from(a) = b
4. 如果 a = super(b)，则type_from(a) = type_from(b)

并推理出如下的定理：
1. 如果a属于objects(c)，b属于objects(c)，那么type_from(a) = type_from(b)
2. 若x为a或任意一个subclass(a) 则type_from(x)不变

哲学家感觉世界上一切都清明了，世界一切都井井有条的在自己的规律下运行，真是完美的理论，哲学家感到很欣慰。

### 哲学家的危机

然而，好景不长，很快聪明又自省的哲学家发现自己构建的世界观存在问题：
  1. 如果对象是由类型对象创建的，有a就有super(a)，就有super(super(a))，
  就有super(...(super(a))...)，难道就没有尽头了吗？世界的源头是什么？
  2. 类型也是对象，可为什么类型能创建对象，一般的对象则不能创建对象呢？
  也就是类型是对象，那么对象是不是类型？这是对称的吗？到底什么使得类型对象成为类型对象？
  3. 无穷的`__call__`。执行`a()`等于执行`a.__call__()`，等于执行`a.__call__.__call__()`，最后等于执行无穷的`a.__call__().__call__().__call__()...` 这必然是不可能的，因为观察到的a()都在有限时间内就执行完返回了

聪明而又敏锐的哲学家意识到自己观察到的尚且属于表象，世界本后尚有真的的规律在运行等待发现。
当然强迫症的哲学家心底里倾向于认为这个世界是对称的，至少自己的理论应该是对称的，否则一切都将会不怎么优美。然而严谨的哲学家怎么能埋没理性而屈从于自己原始而低级的喜好感情呢。

哲学家意识到自己不能再坐在自己的小花园里思考这些问题了，他必须游历世界去寻找真相。

于是我们的聪明又坚毅的哲学家收拾行囊，跋山涉水，餐风露宿，从a找到super(a)找到super(super(a))这么一直找下去...开始了仿佛无尽的探索

### 世界的终极

许多年后，哲学家终于来到了python世界的尽头，无尽的虚空中伫立着两个巨大的存在，从整个世界各处联系汇聚在这两个存在身上，亘古而久远，哲学家相信自己找到了世界的终极秘密。

经过一番研究，哲学家沮丧的发现自己总结的公理在这里失效了。


<hr />
理解type与object的关系关键是区分 类型 与 类类型的继承

所有的东西都是对象 包括type

所有的对象都由type创建 object自然是type创建

所有的新式类都是一种type

继承体系下所有对象的根都是object  type的根也是object
   type也是一种class 因此type有父类型object

__class__属性指的是类型 这里很容易望文生义理解为java里面的那个.Class
__bases__属性指的才是继承


--------------------------------------------------------------------

python中的多继承下继承顺序问题

--------------------------------------------------------------------
python __init__ 与 __new__问题
元类为什么要继承自type
重要区分： 元类是控制type创建类的行为，而不是类创建对象的行为
实际上元类控制创建类行为是使用__new__方法，而该方法继承自type。
实际上所有的对象都是type创建，类是对象，类实例也是对象。那么类创建对象的时候怎么更改默认行为呢？

因为类创建对象也是用type所以，这个更改貌似也应该用元类，只不过最后返回的东西不一样

type.__new__与type()的区别 目前已知二者接受的参数不一样，返回的类型不一样

--------------------------------------------------------------------

元类的使用场景：首先，元类不是反射，反射是从类与对象的外部操纵对象，而元类必须被声明在类的内部。
那么元类是负责类的创建活动。那么所有这个类的创建活动包括其子类的创建活动都被监视了，类的创建包括处理
属性和方法，那么元类就可以对所有这些类的方法和属性做添加、删除或校验规范性。其实如果仅仅是对当前类使用
元类的话，一般有其他替代方法，但是如果对该类的所有子类的创建活动进行监视的话，元类是最好的方法。
java中因为类加载器的存在，这部分监视活动自然转移到类加载器上了。但是java的类加载器可以挂钩子吗？
--------------------------------------------------------------------
