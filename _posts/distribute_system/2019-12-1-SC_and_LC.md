---
layout: post
title: 分布式系列之二：线性一致性与顺序一致性
description: ""
category: 分布式
tags: [分布式]
---
{% include JB/setup %}

* toc
{:toc}

<hr/>

本文主要是阅读论文[《Linearizability: A Correctness Condition for Concurrent Objects》][0]与[《How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs》][1]之后的比较与思考。上面两篇论文后面称之为论文1与论文2。

许多资料都声称线性一致性比顺序一致性更强，也确实如此，但是这两个一致性更多的是应用在不同的场景中。顺序一致性应用于内存模型，在内存模型领域中可以说是最强的一致性了。
内存模型实现线性一致性没有意义。当然因为顺序一致性对程序优化的约束，现代计算机连顺序一致性都不保证。在具体讨论内存模型的文章中我们会看到这一点。

## 操作需要满足的约束

一致性本质上是“惯着上层用户习惯”提供的某种保证。而这个“上层用户的习惯”就是上层用户操作共享数据结构的直觉顺序。
结合顺序一致性与线性一致性，一般而言，有如下三个直觉顺序。

* 因果顺序 读到某个值必定发生在这个值的写入之后。
* 程序顺序（Program Order）。程序的下一步必须可以看见之前的所有的操作，程序顺序是无论如何都要被满足的，否则我们的程序就没法写了。想象一个条件测试语句x==0
执行的时候前面的写入x=1对其不可见，那么整个程序就不会安装人写的时候的意义执行了，一切都混乱了。
* 真实时间顺序 若是共享数据结构有一个统一的时钟，那么多个进程的所有操作都可以认为是发生在某一个瞬间，先发生的必须对后发生的可见。

然而，共享数据结构本身还有一定的数据顺序也要保持，因此，还会有第4个顺序。

* 数据结构约束 队列的FIFO的顺序必须被保持

Lamport的论文《How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs》中要求实现能捕捉因果顺序与程序顺序。
我们来看Lamport这篇论文中对于内存模块的的要求：同一地址的内存读写请求按请求队列顺序执行，而请求队列中的请求要么来自于一个进程是私有内存，要么来自于多个进程是
共享内存。从每个进程来看，其对应的多个请求队列（一个进程会操作多个地址的内存）中，每个相同地址的读写操作必然是遵循程序顺序的，然而同一个进程不同地址的读写操作却允许并行，
前提是可以并行。比如连续的读取x的值与向y写入2自然可以并行，假若y的值依赖于读取的x的值，则没法并行，这种不能并行是隐含在program order里的。


而线性一致性的那篇论文《Linearizability: A Correctness Condition for Concurrent Objects》中，因为其分析的例子中，共享数据结构是队列，队列有自己的顺序。其 实现 实际上要求捕获因果、程序、真实时间三个顺序。当我们把线性一致性应用到共享字典上的时候可以很容易看到这一点。

## 线性一致性
线性一致性是一种捕获所有进程所有操作的实际发生时间先后顺序的一致性。熟悉Lamport分布式时钟那篇论文的很快就会想到，那个全局逻辑时钟实际上就是提供了线性一致性。

### 线性一致性局部性与非阻塞的理解

局部性无疑是一种非常强大的特性，显然他给出了实际应用线性一致性许多便利性，但注意仍要有一个统一的时钟，否则无从谈起线性一致性。

非阻塞指的是上层用户不用等待调用返回，因为线性一致性能捕捉操作发送的实际时间或全局逻辑时间，用户不用等待前面的操作完成，系统会自动保证前面的操作先后后面的操作。

### 线性一致性的验证

论文1中有讨论，暂时未读。

### 无等待算法的实现

论文1中有提及，暂时未读。
http://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf


### 线性一致性的应用场景

文章https://zhuanlan.zhihu.com/p/42239873
提供了一个线性一致性的应用场景。可以看到线性一致性应用在分布式存储中。

## 顺序一致性

顺序一致性，一言以蔽之，就是在进程间保持一种动态的实时的“program order”。
所谓动态的实时的，参考论文2里面互斥算法的例子，当进程B读取a的值结束的时候，进程A的a赋值操作与进程B的a读取操作一定可以确定先后关系了。
因此进程B读取a操作以及之后的所有操作必须能看见进程A写入a以及之前的所有操作。

### 顺序一致性的局部性

根据论文2，很容易看到当共享的数据结构是无顺序的字典的时候，顺序一致性也拥有局部性。
但是当共享数据结构是队列的时候，局部性不能保持，

### 顺序一致性的应用场景

待补充。但猜测顺序一致性作为一种内存模型，现在已经没有了应用场景。

## 无锁算法

无锁算法与无等待算法是一回事么？

## 其他资料
已阅读：
https://pdfs.semanticscholar.org/e436/d7f10aafb0eb83ced1229e32ac2e5f0f64a4.pdf

未阅读：

## 综合思考

论文1里，作者拿事务的序列化与之对比，说明线性一致性是非阻塞的。但我认为这是不同的应用场景导致的。
事务之所以需要阻塞执行是因为后面的事务严格依赖于前面事务的执行成功，那么只有等到回应才说明是成功的。如果有一个事务执行框架
可以保证事务的FIFO，那么上层程序也不需要阻塞，只要程序最后收到一个所有已提交事务都成功的消息就好。

论文1里，作者说不同于Lamport的顺序一致性，线性一致性是具有局部性的。但我认为在原来Lamport的论文的例子中，顺序一致性一样有局部性。
因为原Lamport的论文的例子是基于共享内存，而内存是一个无顺序的数据结构。在队列上，顺序一致性才失去了局部性。这跟我上面讲的“操作需要满足的约束”一节的内容相关。


[0]:https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf
[1]:http://lamport.azurewebsites.net/pubs/multi.pdf
