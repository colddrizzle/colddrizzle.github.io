---
layout: post
title: Time, Clocks, and the Ordering of Events in a Distributed System 
description: ""
category: 分布式
tags: [分布式]
---
{% include JB/setup %}

* toc
{:toc}

本文是Leslie Lamport[论文](http://lamport.azurewebsites.net/pubs/time-clocks.pdf)的翻译。

<hr />

## Introduction

时间概念是我们思考方式的基础。它来自于更基础的一个概念：时间发生的顺序。我们说某件事发生在3点15分指的是它发生时我们的时钟读数刚过3点15分且不到3点16分。通俗的事件顺序的概念渗透到了我们关于系统的思考中。比如，在一个机票预订系统中，如果一次机票预订发生在机舱满员之前，那么这次预订必须被确认。但是，正如我们将要看到的那样，在考虑分布式系统时，必须非常小心的使用事件顺序的概念。

一个分布式系统指的是一些空间上分离、互相之间边界清晰的进程的集合，进程之间通过交换消息来通信。一个互联的计算机网络，比如ARPA，是一个分布式系统。单台电脑也可以被看做是一个分布式系统，它里面中央控制单元、内存单元、输入输出可以被看做是不同的进程。只要一个系统内消息传输的延迟相比于单个进程内事件直接的时间间隔拥有可比性，那么这个系统就可以看作是分布式的。

在这里我们主要考虑一组空间上分离的计算机组成的系统。然而，相关的许多论述可以引申到更广泛的分布式系统中。特别是一个多进程的计算机所涉及到的问题和分布式计算机系统非常类似，因为它们内部的一组特定事件都会有不可预测性的发生顺序。

在分布式系统中，有时候是不可能分清两个事件的先后发生顺序的，因此分布式系统中的 happened before 关系是系统中所有事件的一个偏序关系。我们发现由于人们并没有意识到这个事实以及其隐含影响从而经常导致问题发生。

在这篇论文里，我们讨论了基于“happened before”关系的偏序关系，并且通过扩展它给出一个分布式算法来给系统中所有事件进行总排序。这个算法可以提供实现一个分布式系统的非常有用的机制。我们通过一个解决同步问题的简单的方法展示了如何使用这个算法。出乎意料的是，如果通过这个算法得到的顺序与用户感知到的顺序存在偏差，就会导致系统出现一些奇怪的行为。我们将通过引入一个真实的物理时钟来解决这一问题。
我们描述了一个简单的方法来同步这些时钟，并且给定了同步的偏差上界。

## the partial ordering

很多人都会说，如果事件a发生的时间早于事件b的时间，那么就是事件a发生在事件b之前。他们可能会用物理时钟来解释这一说法。然而，如果一个系统满足某种规范正确性，那么这种规范必须能用系统内发生的事件来观测到。如果这种规范是一个物理时钟，那么这个系统必须包含一个真正的时钟。即便是这个系统真的包含一个时钟，那么这个时钟也不能完全准确（何况物理学中早就没有了绝对时间的概念-笔者注）。因此本文中，我们不用物理时钟而是采用“happened before”关系。

现在我们开始精确的定义我们的系统。我们假设系统是一组进程的集合。每一个进程都包含一些列的事件。根据具体的应用不同，一台计算机上的子程序可以看做是一个事件或者一条机器指令的执行可以看做一个事件。我们假设一个进程里的所有事件形成一个序列，那么事件a出现在事件b之前也就是事件a发生在事件b之前（happened before）。换句话说，一个进程被定义为一组排好序的事件。

我们假设发送和接受消息是一个事件。然后我们就可以定义“happened before”关系了，并用$$\rightarrow$$表示。

定义：系统中所有事件上的“$$\rightarrow$$”关系是满足如下三个条件的最小关系（这里要集合上关系的观点来理解这个最小关系）。
1. 如果a和b是同一个进程中的事件，并且a出现在b之前，那么有a$$\rightarrow$$b。
2. 如果a是发送消息的事件，并且b是同一个消息的接受事件，那么有a$$\rightarrow$$b。
3. 如果有a$$\rightarrow$$b且b$$\rightarrow$$c，那么有a$$\rightarrow$$c。

两个独立的事件a与b之间如果既没有a$$\rightarrow$$b也没有b$$\rightarrow$$a，那么我们就说a与b是并行的。我们假设对任意的事件a都没有a$$\rightarrow$$a。这意味着关系$$\rightarrow$$是非自反关系。

可以用这一张所谓的“空-时图”来帮助我们理解这个定义，如图1.

![img](/assets/resources/lamport-time-clocks-fig1.png)

水平方向代表空间，垂直方向代表事件，越高时间越晚（注意这里的时间是物理时间--笔者注）。竖线代表进程，点代表事件。波浪线代表消息。很容易看到a$$\rightarrow$$b的意思就是我们可以沿着进程与消息在时间增大的方向从a移动到b。比如图1中我们有p1-r4。

另外一种理解这个定义的方法就是如果a$$\rightarrow$$b，那么意味着a的发生因果上影响了b的发生。如果两个事件直接没有互相的因果影响，那么他们是并行的。例如，图1中p3与q3是并行的。尽管图1中我们画的好像q3发生在p3之前（q3的位置更低一些）。进程p在p4时间点收到消息之前，实际上不知道进程q在q3时刻具体在做什么。（在时间p4之前，进程p最多只能猜测进程q可能在进行q3)。

如同资料1[1]或资料2[2]第一章节所描述的那样，对于那些熟悉狭义相对论中静止时空观念的读者来说，这个定义看起非常自然。相对的，事件的顺序用可能被发送的消息来定义，但是，我们可以采用一种更务实的方法，就是只考虑实际上真正被发送的消息，通过只考虑那些确实发生的消息事件而不考虑那些未能发生的消息事件，我们就能确定一个系统是否正确的工作。

## Logical Clock

现在我们将时钟引入到系统中。我们采用一种抽象的观点，所谓时钟就是一种给事件赋予一个数字的一种方法，这个数字也就是事件发生时的时间。更精确的说，我们给每一个进程$$P_i$$定义一个时钟$$C_i$$，该时钟给该进程内的任意一个事件a赋予一个数字$$C_i(a)$$。而整个系统的时钟用一个函数C来表示，其中C(b)=$$C_j(b)$$,b为进程$$P_j$$内的一个事件。现在我们不用做数字$$C_i(a)$$与物理时钟之间关系的任何假设，我们可以把$$C_i$$看做是一个逻辑时钟而不是物理时钟，这个逻辑时钟可以通过一个没有任何计量时间机制的计数器来实现。

我们现在开始考虑基于逻辑时钟的一个系统的正确性（孰先孰后，也就是正确的顺序--笔者注）意味着什么。我们不能用基于物理时钟的正确性的定义，因为那会要求我们引入一个精确的物理时钟。这种情况下，最强的合理条件是如果一个事件a出现在另一个事件b之前，那么事件a的逻辑时间应该早于事件b的逻辑时间。将这个条件形式化为:

Clock Condition:对于任意的事件a、b。若有关系a$$\rightarrow$$b，则有$$C_i(a) < C_i(b)$$。

我们不能想当然的认为反过来也成立：既若没有关系a$$\rightarrow$$b或b$$\rightarrow$$a，则没有有$$C_i(a) < C_i(b)$$也没有$$C_i(a) > C_i(b)$$,也就是有$$C_i(a) = C_i(b)$$。这意味着所有并行的事件必须发生在同一个逻辑时间。在图1中，$$p_2$$与$$p_3$$与$$q_3$$并行，这意味着他们与$$q_3$$发生在相同的时间，显然这与关系$$p_2$$\rightarrow$$p_3$$相矛盾。

很容易从我们的$$\rightarrow$$关系定义看出来，如果如下的两个条件满足，则Clock Condition满足。

* C1. 如果a与b是进程$$P_i$$内的两个事件，并且a出现在b之前，那么有$$C_i(a)<C_i(b)$$
* C2. 如果a是进程$$P_i$$的发送消息事件且b是同一消息在进程$$P_j$$的接受事件，那么有$$C_i(a) < C_j(b)$$。

现在让我们在空-时图中想象我们逻辑时钟的“滴答”数,用虚线代表“tick-line”。那么在物理时间的坐标系下，如图2:

![img](/assets/resources/lamport-time-clocks-fig2.png)

条件C1意味着在同一个进程中事件a与b直接至少有一条tick-line。条件C2意味着任何一个消息至少穿越一条tick-line。

我们可以把这些tick lines当成用逻辑时间坐标系下重新画图2为图3.

![img](/assets/resources/lamport-time-clocks-fig3.png)

到现在为止我们讨论了一个系统中的逻辑时钟应该满足的条件。接下来我们将展示如何在系统中实现这样一个满足Clock Condition的逻辑时钟。进程$$P_i$$的逻辑时钟用计数器$$C_i$$来表示，因此$$C_i(a)$$就是事件a发生时计数器的值。$$C_i$$
的值在事件之间会不断变化，这种变化本身我们并不把它考虑为事件。

为了保证系统逻辑时钟满足Clock Condition。我们保证这个逻辑时钟满足条件C1与C2.条件C1很简单，系统只需要遵循如下的规则：

* IR1: 每当进程$$P_i$$中一个事件发生后，进程递增计数器$$C_i$$。

为了满足条件C2，我们要求每个消息m包含一个时间戳$$T_m$$，时间戳的值为消息m的发送事件的逻辑时钟。接受到该消息的进程必须根据这个时间戳调整自己的时钟的值，精确的说，要满足如下规则：

* IR2: (a) 如果事件a是进程$$P_i$$发送消息m的事件，那么消息m包含一个时间戳$$T_m$$，其值为$$C_i(a)$$。(b)接受到消息m时，进程
$$P_j$$将自己的时钟设置为一个比$$T_m$$大且不小于自己当前时钟$$C_j$$的新值。

在条件IR2中，我们认为接受消息的事件发生时间发生在调整$$C_j$$之后，整个操作是一个原子操作。显然IR2保证了条件C2的满足。显然IR1与IR2的简单实现保证系统满足Clock Condition，所以他们保证了一个正确的系统逻辑时钟。

## Ordering the Events Totally

我们可以用一个满足Clock Condition的系统时钟来为系统中的所有事件进行排序。为了打破可能存在的逻辑时钟相等关系，我们使用进程之间的存在任意一个排序的排序关系（比如进程号等等，这仅仅是为了打破逻辑时钟相等的而设立的）。更精确的说，我们定义系统中所有事件上的一个关系$$\Rightarrow$$如下：

对于系统中任意的两个事件a与b，a属于进程$$P_i$$,b属于进程$$P_j$$。若满足下面条件之一
1. $$C_i(a) < C_j(b)$$
2. $$C_i(a) = C_j(b)$$且$$P_i < P_j $$

则称a与b直接满足关系a$$\Rightarrow$$b。很容易看到我们定义了一个全排序关系。并且时钟条件意味着如果存在a$$\rightarrow$$b的偏序关系则存在a$$\Rightarrow$$b的全序关系。

全序关系$$\Rightarrow$$依赖于系统的逻辑时钟$$C_i$$并且不是唯一的。所有的全序关系中，只有其中的偏序关系$$\rightarrow$$是唯一确定的。（另外全序关系中存在a$$\Rightarrow$$b不再体现a与b的并行或者因果关系--笔者注）

在实现分布式系统中能够实现全排序将会非常有用。实际上在系统中正确的实现一个逻辑时钟的目的就是为了能够进行事件的全排序。下面我们将展示使用这个全排序来解决分布式系统中的互斥问题。考虑这样一个系统，它有一组确定固定的进程并且共享某一个单例资源。在同一时间只有一个进程能够使用该资源，因此所有的进程在使用该资源的时候必须进行同步以避免竞争。

我们希望能找到一个算法用来把资源分配给进程，这个算法必须满足三个条件：
* (I) 资源在分配给其他进程之前，其原来占用资源的进程必须先释放它。
* (II) 授予进程资源的顺序必须按照他们请求资源的顺序来
* (III) 如果每一个得到资源的进程最终都会释放资源，那么每一个资源请求都会被授予资源。

我们假设初始状况为：资源一开始授予了某个进程。

这些都是很自然的要求，这些要求很明确的规定了什么是正确的解决方案。条件(II)并没有给出两个并行的资源请求哪一个应该先被授权。

特别重要的是，我们要意识到这不是一个微不足道的问题。使用一个中央调度进程并不能解决问题。除非再加上一些假设。为了弄清楚这一点，让我们假设$$P_0$$是中央调度进程，假设$$P_1$$向$$P_0$$发出资源请求然后又向$$P_2$$发送了一个消息。$$P_2$$接受到消息之后也向$$P_0$$发出资源请求，那么久很有可能$$P_2$$的资源请求先于$$P_1$$的请求到达。如果因此$$P_2$$的请求先被授权那么条件(II)就被破坏了。

为了解决这一问题，我们用规则IR1与IR2实现一个系统时钟，然后用他们来定义一个系统事件的全排序关系。这就为系统中所有的资源请求与释放事件定义了一个全排序关系。在这个全排序下，找一个解决方案就变得非常直接，只需要保证每个进程都能感知其他进程的所有操作。

为了简化程序，我们引入一些假设，这些假设并不是必须的，只是为了不让我们为了考虑实现细节而分心。首先我们假设对任意的两个进程$$P_i$$与$$P_j$$，从$$P_i$$到$$P_j$$的所有消息都按照它们发送的顺序被接受，这还意味着所有的消息最终被接受到（这个假设可以通过消息编号与消息确认协议来实现）。我们还假设任意两个进程之间都可以直接通信。

每一个进程都维护有自己的一个request queue，并且不能被其他进程观察到内容。我们假设一开始request queue里面包含一个消息 $$T_0:P_0 request resource$$，其中$$T_0$$是一开始被授权的进程，$$P_0$$是小于所有进程的初始时钟值的任意一个值。

这个算法被如下的5条规则所定义。为了方便，每条规则定义的行为都构成一个单独的事件。

1. 为了请求资源，进程$$P_i$$向所有的其他进程发送一个消息$$T_m:P_i request resource$$，并且把该消息放入request queue中，其中$$T_m$$是消息的时间戳(进程在得到资源之前只会发送一次request resource，不会反复发送，也就是任何时刻所有的进程request queue中最多包含一个$$P_i$$的request resource消息---笔者注)

2. 当进程$$P_j$$收到消息$$T_m:P_i request resource$$时，它将该消息放入request queue，并且向进程$$P_i$$回复一个带有时间戳的ack消息。（规则2时间上有一个接受一个发送两个事件，同一个时间戳，那为什么上面说是堪称一个事件呢？ack事件的影响？）


3. 为了释放资源，进程$$P_i$$清空request queue中有的$$T_m:P_i request resource$$(进程自己的请求资源消息)消息，然后向所有的其他进程发送一个带有时间戳的$$P_i release resource$$消息。

4. 当进程$$P_j$$收到进程$$P_i$$的release resource消息时候，它将request queue中的所有$$T_m:P_i request resource$$消息(来自进程$$P_i$$的资源请求消息)清空。

5. 当满足如下两个条件时，进程$$P_i$$被授予资源 (i) 在它的request queue里有一个$$T_m:P_i request resource$$，并且该消息在全序关系$$\Rightarrow$$下早于队列中其他所有的request resource消息(我们用发送消息时的时间戳而不是接受消息时的时间戳来构建这个全排序关系)。(ii) $$P_i$$从所有其他进程都接受到了一个消息，且这个消息晚于$$T_m$$(这个消息不区分类型吗?至少有request release ack三种消息啊)

很容易验证上述规则定义的算法满足条件I-III。首先考察规则5的条件(ii)，再考虑到消息按顺序接受的假设，该条件意味着进程$$P_i$$已经感知到了先于自己的当前request resource请求的其他所有请求。既然规则3与4是唯一的删除请求的规则，（而当前进程没有占有资源且当前队列中没有其他进程的request resource消息(该消息代表其可能占有资源)，可以推定其他占有资源的进程一定发送了release resource消息，且其他所有进程没有再发送任何早于当前进程请求的请求消息--笔者注）很容易看到条件(I)满足。条件(II)遵循全序关系$$\Rightarrow$$是扩展于偏序关系$$\rightarrow$$的事实(？？条件(II)的满足是因为请求的顺序是逻辑时钟下的先后顺序，而这个先后顺序跟偏序关系有什么关系呢？不一定是偏序关系啊，比如一开始所有的进程发送资源请求，那这些请求的时间戳都是0，其顺序其实满足进程之间的那个排序关系。所以这里存疑)。规则2保证了进程$$P_i$$请求消息后最终会收到一个返回消息，保证了规则5(ii)的满足。规则3与4意味着所有被授权资源的进程最终都会释放资源，规则5(i)最终会被保证。从而保证了条件(III)。

<hr/>

>关于这个算法的理解：首先要注意到该算法假设消息按顺序接收且最终一定会被接收到，这是一个非常强的假设。第二个要注意到规则5(ii)要求接收到每个其他进程的至少一个晚于$$T_m$$的消息，怎么保证其他进程一定会发送这个消息呢？这就是rule2里面ack消息的作用。所以说论文下面注解说若已经向消息来源发送了一个晚于接收消息时间戳的消息，则不用发送该ACK。

<hr/>

$$\rightarrow \varphi \Rrightarrow$$

这是一个分布式算法。每个进程独立的执行这些规则，没有中央同步进程或中央存储信息。在逻辑时钟定义的分布式系统中，这个算法可以被推广用来实现任意想要的同步算法。这个同步过程可以用状态机的术语来描述。这个状态机包含一个命令集合**C**与一个状态集合**S**，还有一个函数**e**:**C**x**S** $$\rightarrow$$ **S**。
关系**e**(**C,S**)=$$\textbf{S'}$$是状态转换函数。在上面的例子中，集合C包含进程$$P_i$$所有的request resource与release resource命令，状态集合就是请求队列，其中请求队列的头所代表的进程就是被赋予资源的进程。执行request命令给队列的尾部添加一个请求，执行release命令从队列的头部删除一个请求。

未完待续。有部分尚未翻译。

## Anomalous Behavior

我们的资源调度算法使用全序关系$$\Rightarrow$$来给请求排序。这会导致一种“怪异的行为”(这种怪异是相对于我们的物理时空而言的--笔者注)。考虑有一个覆盖全国的互联计算机网络。假设一个人从计算机A发送了一个请求a，然后打电话给另一个城市的朋友让他从另一台电脑B上发送请求b。那么就有可能请求b的逻辑时钟时间戳要小于a的逻辑时钟时间戳从而导致排在a的前面。这是非常可能发生的因为系统没有办法知道请求A确实发生与请求B之前，因为这些信息是系统之外的。

让我们更深入的检查这一问题的根源。令$$\varphi$$为整个系统内所有事件的集合。令$$\underline{\varphi}$$为系统内所有事件以及系统外所有相关事件的集合。令关系$$\Rrightarrow$$表示集合$$\underline{\varphi}$$内的"happened before"关系。
在我们的例子中个，我们有$$A \Rrightarrow B$$，但是没有$$A \rightarrow B$$。显然没有任何算法能够仅依靠$$\varphi$$内的事件断定请求a一定先于请求b.

有两种可能的方法能避免这种怪异的现象。第一种方法是明确的将所有必要的信息都引入到系统中。在我们的例子中，只要保证请求b的时间戳晚于请求a的时间戳，然而这要求用户来避免这种怪异的行为。

第二种方法是构建一个系统时钟满足如下的条件:

Strong Clock Condition：对于$$\varphi$$内的任意事件a与b,如果有$$a\Rrightarrow b$$那么有C(a)<C(b)。

这是一个比先前的逻辑时钟更强的时钟，因为关系$$\Rrightarrow$$比$$\rightarrow$$强。

让我们用物理时空中的一些“真实”事件来刻画集合$$\underline{\varphi}$$，用$$\Rrightarrow$$代表狭义相对论下事件的偏序关系。宇宙的众多秘密之一是：构建一个依靠物理时钟的系统来满足Strong Clock Condition是可能的，且这些物理时钟彼此相对独立的运行。如此我们就可以用物理时钟来消除这种“怪异行为”，下面我们重心转向这种时钟。（讨论了半天最后还是物理时钟，先前的讨论有什么意义？？？）

## Physical Clocks

让我们给我们的时空图引入一个物理时间的坐标系。令$$C_i(t)$$表示时钟$$C_i$$在物理时间t的读数（我们使用的牛顿时空，也就是有一个绝对时空的概念，如果时钟的相对运动或者引力影响不可忽略，那么$$C_i(t)$$必须考虑这种偏差）。为了数学上表述方便，我们假设这个时钟是一个连续的时钟，没有实体时钟的精度的概念，是一个无限精度时钟。然后用$$dC_i(t)/dt$$表示时钟在时间t时的走动速率。

为了让时钟$$C_i$$能像真的物理时钟那样，它必须以大致正确的速率走动。就是说，
对于所有的时间t，必须有$$dC_i(t)/dt\approx 1$$。跟准确的说，我们假设如下的条件被满足：

* PC1. 存在一个常量$$k \ll 1$$，使得对于所有的i，存在$$ abs(dC_i(t)/dt-1)< k$$。对于一般的石英时钟而言，$$k\leq10^{-6}$$。

仅有这个条件还不能让独立的时钟大致以正确的速率运行。这些时钟直接必须被同步使得对于所有的i,j,t，有$$C_j(t)\approx C_j(t)$$。更精确的说，必须存在一个相当小的常量$$\epsilon$$使得下面的条件成立。

* PC2. 对于所有的i,j：存在$$abs(C_i(t)-C_j(t)) < \epsilon$$

如果我们把图2中的垂直方向的距离当做物理时间，那么PC2讲的是单独的一个tick line的高度变化小于$$\epsilon$$。（也就说几乎是完全水平的，而不是图2中的折线---笔者注）

既然两个完全不同的时钟永远不可能以相同的速度走动，时钟之间将倾向于差距越来越大。我们必须用一个算法来保证PC2永远保持。首先，让我们考察需要多小的k与$$\epsilon$$来避免“怪异行为”的发生。我们必须确保系统$$\underline{\varphi}$$相关的物理事件满足Strong Clock Condition。我们假设我们的时钟满足原来的那个Clock Condition，那么当$$\underline{\varphi}$$内的事件a与b没有$$a\rightarrow b$$关系时，Strong Clock Condition能保持。因此，我们只需要考虑发生在不同进程内的事件。

令$$\mu$$为一个数字使得：如果事件发生在物理时间内的事件a与发生在另一个进程内的事件b满足$$a\Rrightarrow b$$，那么b要发生在物理时间$$t+\mu$$之后。换句话说，**$$\mu$$是一个小于进程之间消息传输最短时间的值**。 我们总是可以根据光速在最短的两个进程之间传输的时间来选择一个$$\mu$$。然而，根据$$\underline{\varphi}$$内时间传输方式的不同，通常$$\mu$$会稍微大一些。

为了避免怪异行为，我们必须保证对任意的i,j,t有$$C_i(t+\mu)-C_j(t)>0$$。结合这个与PC1和PC2，使得我们可以像下面那样将所要求的最小的k与$$\epsilon$$与$$\mu$$的值关联起来。我们假设当时钟调整的时候，总是向前调整(向后调整会导致违反C1)。
PC1意味着$$C_i(t+\mu)-C_i(t)>(1-k)\mu$$。根据PC2,很容易推论出：

如果不等式$$\epsilon/(1-k)\leq \mu$$满足，那么有$$C_i(t+\mu)-C_j(t)>0$$。

这个不等式与PC1和PC2一起保证了“怪异的行为”是不可能发生的。

我们现在继续构建我们的算法保证PC2满足。令m为一个消息，其在物理时间t发送并在物理时间t’被接收。我们定义$$v_m = t'-t$$为消息m的总延迟(total delay)。当然接收消息m的进程并不知道这个延迟m。然而，我们可以假设接收进程知道某个最小延迟(minimum delay) $$\mu_m \geq 0$$，因此有$$\mu_m \leq v_m$$。我们称$$\\xi_m = v_m$$为消息的不可预测延迟。

现在我们可以给我们的物理时钟制定规则IR1'与IR2'。

* IR1'：对每一个i，如果进程$$P_i$$没有在物理时间t接收到消息，那么$$C_i$$在时间t是可分辨且$$dC_i(t)/dt >0 $$。

* IR2'：(a)如果进程$$P_i$$在物理时间t发送了一个消息，那么m包含一个时间戳$$T_m = C_i(t)$$。(b)进程$$P_j$$在物理时间t'收到消息m后，设置$$C_j(t')$$为$$max(C_j(t'-0),T_m+\mu_m)$$(其中$$C_j(t'-0) = lim_{\delta \rightarrow 0} C_j(t'-abs(\delta))$$).

虽然规则用物理时间下的参数形式化了，但一个进程只需要知道自己的时钟读书以及接受到的消息时间戳。为了数学上方便，我们假设每一个事件都是发生在一瞬间，同一个进程内的不同事件发生在不同的时间。这些规则是规则IR1与IR2的特殊形式，因此我们的系统满足 Clock Condition。真实的事件有一个有限的持续事件这个事实使得实现这个算法没有难度。实现中唯一需要真正考虑的是确保实体时钟走的足够均匀使得C1能够保证。

我们现在论证这种时钟同步算法可以满足PC2.我们假设整个系统可以被描述为一个有向图，其中$$P_j$$指向$$P_j$$的一条弧代表这两个进程可以直接通信。如果对任意时间t,进程$$P_i$$在物理时间t与t+$$\tau$$之间向$$P_j$$发送至少一条消息，那我们称每$$\tau$$秒就有一个消息经过该弧。这个有向图的直径(diameter)是满足如下条件的最小d:对任意的两个进程，这两个进程之间最多有d个弧。

为了建立PC2,下面的定理界定了系统启动时候时钟同步完成需要的时间。

THEOREM:假设一个直径为d的进程的强连通图总是遵循规则IR1'和IR2'。假设对任意的消息m,对满足$$\mu_m \leq \mu$$的某些常量$$\mu$$，以及对所有的$$t\geq t_0$$: (a)PC1满足。(b) 存在常量$$\tau$$与$$\xi$$使得每隔$$\tau$$秒就要一个不可预测延迟小于$$\xi$$的消息经过每一条弧。那么对所有的$$t\geq t_0+\taud$$有$$\epsilon \approx d(2k\tau+\xi)$$的条件下，PC2满足，其中粗略估算假设$$\mu+\xi \ll \tau$$。

这个定理的证明相当的难，附录给出了该证明。关于同步物理时钟还有大量的工作要做。推荐给读者资料[4]参考，该资料做了一个该主题的介绍。本文中描述的方法可以用于估算消息延迟$$\mu_m$$和调整时钟速率$$dC_i/dt$$。然而，时钟永远不往回调整的要求似乎区别与我们之前学习到的情况，我们相信该理论是一个新的成果。

## Conclusion

暂略。

## Reference
1. Schwartz, J.T. Relativity in lllustrations. New York U. Press, NewYork, 1962. 
2. Taylor, E.F., and Wheeler, J.A. Space-Time Physics, W.H.Freeman, San Francisco, 1966. 
3. Lamport, L. The  implementation  of reliable distributed multiprocess  systems. To appear in Computer  Networks.
4. Ellingson, C,  and Kulpinski,  R.J. Dissemination  of system-time. 1EEE  Trans.  Comm.  Com-23,  5 (May 1973), 605-624. 


## 思考

Q1:全局逻辑时钟的作用就是给全局事件确定一个唯一且不同的编号吗？

A1:不是。如果仅仅是一个全局唯一且不同的编号，最简单办法就是每个事件hash一个时间戳，或者用(进程编号，进程内事件编号)这样一个组合编号都可以搞定。
重要的是要满足因果关系，特别是发送消息与接收消息直接的因果关系。这就是规则5(ii)里能保证肯定能收到一个大于当前请求时间戳的ack消息，加入这个ack的消息比当前请求的时间戳小，且发送ack的这个进程不再发送其他请求消息，那么5(ii)就没法保证了。

Q2:如何保证消息按顺序接收?

A2:每个进程给自己发送的所有的消息顺序编号就可以了。进程之间互相独立。当接收进程$$P_j$$收到进程$$P_i$$的5号消息但没有收到4号消息的时候，那么5号消息先保存在接收队列里延迟交付，直到收到4号消息为止。

Q3:消息发送延迟怎么办？

A3:一直等待或按宕机处理。若按宕机处理，必须有一个宕机的协议


Q4:设想一个宕机后删除进程的协议

A4:首先是怎么发现某台机器宕机。需要心跳包，那同时心跳包会更新各个进程上的逻辑时钟。那要多少进程都发现某进程的心跳包丢失才算是宕机呢？
持有资源的宕机与非持有资源的宕机

Q5: 假如在上述宕机进程删除协议进行中的时候，原来因为网络延迟的心跳包发送来了会怎么样？ 

A5: 删除进程的协议应该中止还是要进行重新类似决策是否删除进程。

Lamport本人在[自己网站上][0]说，本文最重要的思想是状态机的思想，但是我还没能体会到。留作以后思考。

[0]:http://lamport.azurewebsites.net/pubs/pubs.html#time-clocks