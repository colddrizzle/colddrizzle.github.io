---
layout: post
title: 面包房算法的分析理解
description: ""
category: 分布式
tags: [分布式]
---
{% include JB/setup %}

* toc
{:toc}

<hr/>

本文翻译自Lamport论文[“A New Solution of Dijkstra’s Concurrent Programming Problem”][0]

在这篇论文中，Lamport给出了一个多进程互斥算法，lamport本人非常看重这个算法，这是一个神奇的算法，它甚至不要求读写操作的原子性，也不关心读操作返回的任何值，lamport在其[网站][0]上甚至说之后的不少成果根源于此，甚至说关于并发的一切都是来自研究该算法。

## 部分翻译

进程共有的存储包含以下内容:

```
integer array choosing[1:N], number[1:N]
```

choosing[i]与number[i]存储在进程i的内存中并被初始化为0.
number[i]的值的范围是无界的，稍后再讨论这一点。

下面是进程i的程序。执行必须从非临界段开始。maximum函数的参数可以任何顺序参与运算。整数对的“less than关系”定义为(a,b) < (c, d)成立，当a < c或者a = c但b < d的时候。

```
//something before

begin integer j;

	L1: choosing[i] := 1
		number[i] := 1 + maximum(number[1], ..., number[N]);
		choosing[i] := 1
		for j = 1 step 1 until N do

			begin
				L2: if choosing[j] != 0 then goto L2;

				L3: if number[j] != 0 and (number[j], j) < (number[i], i) then goto L3;
			end;
		critical section;
		number[i] := 0
		noncritical section;
		goto L1;
end

//something after
```

我们允许进程i在任意时刻失败,然后在非临界区重启（同时choosing[i] = number[i] = 0）. 然而，如果一个进程一直失败重启，那么整个系统会死锁。

## Proof of Correctness

为了证明这个算法的正确性，我们做出如下定义。称进程i为在门口，当 choosing[i] = 1的时候。称进程i为在面包房内，从进程重置 choosing[i]为0到进程失败或者离开临界区。算法的正确性由如下的断言推论而出。
注意，该断言没有做读写重叠的任何假设（读写操作可以是非原子的）。

断言1. 如果进程i与k都在面包房之内，并且i进入面包房的时间早于k进入门口的时间，那么有number[i] < number[k].

断言1的正确性是显而易见的。

> 什么叫早于？虽然此处可以以“绝对时间”或者统一时钟周期来理解，但都包含假设的意味，因此我们理解为在内存上开来，进程i的choosing[i]变为0先于进程j的choosing[j]变为1.

> 除了断言1中的条件之外，其他任何情况都不足以保证number[i] < number[k]。比如进程早于进程j进入面包房，则有可能number[i] >= number[k]。

>为什么断言1没有对读写做出原子假设。因为断言1中choosing[i] 置为0与choosing置为1 都关心的是值变化的瞬间，而不是关心值改变的过程。

断言2. 如果进程i在临界区，进程k在面包房，且 k不等于i。 那么有(number[i], i) < (number[k], k)

>注意该断言并未对进程k是否在临界区做出任何声明。

证明： 既然 choosing[k] 只有0 与 1两个值。 从进程i的视角看来，我们可以假设，读写这个值是一瞬间的事，同时的读与写不会同时发生。例如，如果 choosing[k]正从0变为1，同时这个值正被另一个进程i读取，那么这个读取要么读到0，从而读发生在写之前，要么读到1从而写发生在读之前。所有的时间都是以进程i的视角来定义的。

>其实上面还是做了写操作原子性的假设，即便是1到0的变化，我们依然无法断定下面的硬件如何实现，只有当0与1的存储编码只差一个bit的时候，这种假设才是正确的，因此lamport的这里有错。幸运的是，最常使用的intel处理器规范保证了读写一个字的原子性（引证？）。

令$$t_{L2}$$为进程i最后一次执行L2且j = k时 读取choosing[k]的时间。令$$t_{L3}$$为进程i执行最后一次L3且j=k时的时间，因此有
$$t_{L2} < t_{L3}$$。当进程k选择number[k]的当前值的时候，令$$t_{e}$$为进程k进入门口的时间。$$t_{w}$$为进程k写完number[k]的值的时间。$$t_{c}$$为进程k离开门口的时间。那么有$$t_e < t_w < t_c $$。

>进程i肯定会有最后一次执行L2的时候，怎么保证有j=k呢？有j=k且最后一执行意味着choosing[k] = 0, 意味着进程k不在门口。断言2规定了进程k在面包房内。断言2为什么要规定在面包房内呢？ 从进程i的视角来看，其他进程要么在门口要么不在门口，因此可能没有j=k。而我们只关心进程k是否进入临界区打破算法，若进程k在门口那么其肯定不在临界区，我们也自然不用关心。就算其他所有的进程都在门口，L2遇到j = i的时候也会退出循环。

既然choosing[k]在时间$$t_{L2}$$的时候为0，我们要么有(a) $$t_{L2} < t_e$$ 要么有 (b)$$t_c < t_{L2}$$。在情况(a)中，根据断言1有 number[i] < number[k]， 因此断言2成立。

情况(b)的时候，我们有 $$t_w < t_c < t_{L2} < t_{L3}$$，因此有$$t_w < t_{L3}$$。因此，在开始于$$t_{L3}$$时刻的L3语句执行期间，进程i读取了number[k]的当前值。既然进程i因为j=k不再执行L3，那么它一定有(number[i], i) < (number[k], k)。 因此，情况(b)下断言成立。

断言3. 假设只会发生有限的进程失败。如果没有进程在临界区且在面包房里有一个没有失败的进程，那么一些？进程将最终进入临界区。

证明：假设没有进程进入过临界区。那么总会在经过一段时间后，没有进程进入或者离开面包房。此时，假设在面包房的所有进程中进程i拥有最小的(number[i], i)。那么进程i最终将完成for循环进入临界区。从而与开头假设矛盾。

断言2意味着任何时候最多有一个进程在临界区中。断言1与断言2证明进程之间按照FIFO的顺序进入临界区。因此，一个单独的进程不能被阻塞除非整个系统死锁。断言3意味着除非某个进程在临界区挂掉，否则不会死锁。

如果进程j持续的失败重启，运气坏的情况下，进程i将会永远发现choosing[j] = 1， 因而永远在L2循环。

## Further Remarks

如果在面包房里总是至少有一个进程，


## 思考

算法中用choosing标记进程进行选号的过程。当前进程选号结束后其choosing必定为0且number大于0. 因此L2循环最多循环到i必定结束，L3循环也是至多循环到i必定结束。L2循环目的就是判断是否有比自己的进程号小的进程没有进行选号，这意味有比自己进程号小的进程可能处于面包房内，也可能不在该算法的执行范围内（没有运行到该算法或者已经运行了该算法，就是上面代码的before与after部分）。若有则进一步的判断。L3首先判断number是否为0，为0则说明尚未选号，其次判断是否进程号比自己小的进程是否拥有更小的选号。若有则不进入临界区。

可以看到整个算法的设计思路是一种类似黑名单的设计思路。算法大致可以分为两个部分：选号部分以及“黑名单”判断部分。

先说黑名单部分，代码思路可以理解为我不关心我什么时候应该进入临界区，我只关心我什么时候绝对不能进入临界区。这不像加锁的算法，加锁的算法代码部分关心的是我什么时候可以进入临界区，这是一种白名单的思路。我猜测其他所以的无锁的互斥算法都是这个思路。

重要的是最后要给出证明，证明的这样的思路最终会使所有的进程都能以某种顺序进入临界区而不是进入死锁，这个证明才是最难的。


再说选号部分，这部分可以根据Lamport分布式时钟的那篇论文来理解。选号的大小代表了选号操作的先后顺序，根据逻辑时钟的概念，逻辑时钟不能违背事件之间的因果关系。

现在我们定义如下的因果关系。若进程i的选号过程中，其从进程j中读取number值的操作发生在进程j写入自己的number值操作之后。则认为进程i的选号操作发生在进程j的选号操作之后。

注意，存在这样一种情况，假若两个进程同时根据同一时刻的number[1..N]数组选出自己的号码，则这两个号码必然相等，这两次选号操作之间也没有因果关系，可以认为是并行的。

那么现在我们就需要建立一个逻辑时钟，使其不违背上述因果关系，且能给所有的选号操作进行排序。

显然，为了不违背上述因果关系，进程i在时刻t的时候其选号要大于当前所有其他进程的选号。因此有1 + maximum(number[1], ..., number[N])。当进程选号相同的时候，根据进程号确定先后关系。如此(number[i], i)就我们要找的全局逻辑时钟。

Lamport说该算法启发了他之后的所有研究诚不欺我。

最后，我们看下面包房算法为什么不会死锁？假若存在死锁，则存在进程在循环L2或L3处死循环，显然因为当前choosing=0，L2绝不会无限循环。那么就是L3死循环，若L3死循环，要么所有的number[j]=0，显然当前number[i] >= 1，因此不成立，则必然是进程i每次都发现(number[j], j) < (number[i], i)成立。若该条件成立，其他的进程j中该条件必然不会永远成立，因此其他进程j会有一个跳出L3循环，进入临界区。而其他进程只要不在临界区挂掉，必然会再次选号，由于进程i已经死循环在L3，其number[i]的值最终会被超过，从而导致进程i无法在L3处永远循环，因而矛盾。

[0]:http://lamport.azurewebsites.net/pubs/pubs.html#bakery