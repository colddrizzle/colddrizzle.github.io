---
layout : post
category : 编译
tags : [编译,栈帧]
title : C语言下栈帧结构与函数调用过程
---

讲解之前首先明确一下call与ret指令到底做了什么

再一个，push pop指令也会影响esp指针


我们知道，函数调用是通过栈来实现的，那么这个过程具体是如何呢？

不妨先忘掉栈，假如我们来实现函数调用会怎么做。
函数调用这个过程要满足一下几点：
* 将调用参数放在某处
* 调用者保存当前函数执行断掉的位置
* 跳转到被调用函数
* 函数取得参数，进行运算
* 运算结果保存在某处
* 被调用者跳转到调用者断掉的位置
* 取得被调用者的运算结果

从上面的过程大致可以看出，被调用者与调用者要约定：
* 参数的存放位置
* 结果的存放位置
* 调用者断掉的地址的存放位置

再一个，被调用函数运算过程中还可能继续进行函数调用，于是上述三个位置需要多对，但是呢同一时刻只有一个函数调用结果等待交付，因此结果的存放位置可以复用，而其他的要可扩展，于是自然想到用**一块连续的内存**来依次存储：![链表][0]

可以看到每一个函数对应一组数据<断点位置，参数>，姑且称之为**一帧数据**好了。

假设我们的机器数据总线与地址总线都是32位，那么断点地址占用4个字节，参数类型包括整型、浮点数和指针，那么一个参数也占用4个字节，CPU的当前指令位置用PC表示，并且连续内存的存储从高地址向低地址扩展，并用指针LP表示最后**一帧数据**的结束地址，那么我们模拟一下函数调用过程：
![链表][1]

1. LAST_LP <- LP      保存LP的初始值 也就是调用者那一帧的结束地址 
2. LP <- LP - 4       预留断点位置的存储空间
3. 存入参数 LP <- LP - 4
4. 如果还有参数，重复步骤3 。否则到步骤5。
5. 调用函数，在调用函数之前断点位置存入步骤2的预留空间 PC <- 被调用者地址
6. 被调用者从LP开始读取参数

咦？好像出问题，被调用者怎么知道从哪儿开始读取参数，又怎么知道读取到哪儿结束呢，又怎么知道参数类型的呢？
对于第一个问题，读取参数直到内存地址为LAST_LP-4。这就是为啥要保存LP的初始值的原因了。
那么保存LAST_LP是在调用函数的上下文中，被调用函数又是怎么知道的呢？简单，把这个也放入一帧数据中，这个地址也占用4个字节，
相应的，前面的步骤改为：
1. LAST_LP = LP
2. LP = LP - 8 预留断点位置和LAST_LP的存储位置

进一步，为了避免预留位置这一步有点绕的操作，我们将**一帧数据**中的参数放在最前面，断点位置放后面，LAST_LP放在中间。
于是我们的存储结构变成了：![链表][2]
1. LAST_LP <- LP
2. LP <- LP - 4 存入参数
3. 如果还有参数，重复步骤2 。否则到步骤4。
4. LP <- LP - 4 存入LAST_LP
5. 调用函数。在调用函数之前, LP <- LP - 4 然后在LP指向位置存入断点地址  PC <- 被调用者地址
6. 被调用者取出LAST_LP   LAST_LP <- 读取LP+4处内存的值。 被调用者从LP+8处开始读取参数，一直读到LAST_LP为止。
7. 被调用者执行运算，结果放入约定的结果寄存器
  接下来就要回到调用者步骤了，注意调用者也需要根据LP寻址自己的参数，因此需要恢复调用者的LP
8. LAST_PC <- 取出LP处的断点地址 LP <- LP+4
9. LP <- LAST_LP  恢复调用者那一帧数据LP的值 缩减了LP也相当于释放了被调用者的那一帧数据。
10. PC <- LAST_PC 跳转到调用者断点处继续执行
11. 从约定寄存器中取出结果 



[0]:/assets/resources/stack_frame_1.png
[1]:/assets/resources/stack_frame_2.png
[2]:/assets/resources/stack_frame_3.png


