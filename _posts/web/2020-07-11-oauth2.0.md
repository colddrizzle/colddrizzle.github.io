---
layout: post
title: 看图学OAuth 2.0--一目了然
description: ""
category: web
tags: [web,oauth2.0]
---
{% include JB/setup %}

* toc
{:toc}

<hr />

未写完 待补充

## 四种角色

![img](/assets/resources/rfc6749/roles.png)

## 抽象协议流程

![img](/assets/resources/rfc6749/abstract-protocol-flow.png)

## 四种获取授权方式

### 授权码授权
这是最安全的一种方式。

![img](/assets/resources/rfc6749/authorization-code-grant.png)

`^`是箭头。user-agent用户代理，也就是浏览器、手机端、桌面端程序等。流程A、B、C被分成了两部分。

在授权码授权之前，client已经向resource server所在一方注册过，注册是需提供appid与与一个域名，
后续提供的redirect_uri必须是该域名下的地址。

上个图中并未给出注册流程，以微信公众号平台为例：用户提供域名与appid，公众号平台返回用户一个secrect与code，
其中code就是授权码，secret与appid相当于构成了用户自己应用的账户。


### 隐藏式授权

![img](/assets/resources/rfc6749/implicit-grant.png)

### 资源所有者密码凭证授权

![img](/assets/resources/rfc6749/resource-owner-password-credentials.png)

### 客户端凭证

![img](/assets/resources/rfc6749/client-credentials.png)

## 安全考虑-WhatIf

本小节目的是帮助理解Oauth做这样的设计背后有什么样的安全考虑。

### 授权码授权WhatIf

#### 如果第三方注册时不提供域名会怎么样

在授权码授权流程中，步骤A与D都需要携带一个redirect_uri，要知道Oauth请求是一个Http请求，
而在请求A中clientID是公开的，攻击者可以构造一个特殊redirect_uri然后骗取用户在自己的UserAgent会话期间
点击（比如微信群发一个链接，每个接受者点击链接都携带有自己与微信服务器的会话信息）但是获得的code被发送到
攻击者自己的服务器上。类似地更改步骤D的redirect_uri，则攻击者拿到了用户的token，此时再访问用户的资源不再要求会话信息。

注意Oauth Authorization Server并不会对redirect_uri做身份验证（）。

#### 如果没有code会怎么样
OAuth2.0为什么要现申请code呢？如果没有code会怎么样？

对于code的作用，RFC6749是这么说的：

	code
         REQUIRED.  The authorization code generated by the
         authorization server.  The authorization code MUST expire
         shortly after it is issued to mitigate the risk of leaks.  A
         maximum authorization code lifetime of 10 minutes is
         RECOMMENDED.  The client MUST NOT use the authorization code
         more than once.  If an authorization code is used more than
         once, the authorization server MUST deny the request and SHOULD
         revoke (when possible) all tokens previously issued based on
         that authorization code.  The authorization code is bound to
         the client identifier and redirection URI.

可以看到code的有效期非常的短，推荐是10分钟，并且只能使用一次，而且一旦发现使用了一次以上，连之前授权的token也会被取消权限。

RFC6459 10.5节讲的很清楚，之所以要有code是为了能在HTTP上使用OAuth的时候也能最大限度的保证安全。

Http相比于Https的缺点是缺乏身份认证，容易被“中间人攻击”。有code的情况下，即使code被中间人截获，该code获得的access token的权限也不会长久。
因为用户正常流程来说，获得code就会马上使用code（code的有效期很短）。中间人先用了code也只会泄漏一丁点儿信息，随扈用户与攻击者度不能访问了。
最大限度的在HTTP上保证了OAuth的安全。

注意，在授权码授权的流程图中，步骤A与步骤D依赖于重定向，因此必须工作在HTTP协议之上，而步骤E可以通过加密TCP连接传输。因此token不会被中间人攻击。

#### 不使用secret 会怎么样
使用secret是[资料][0]中提到的“各个公司在实现 OAuth2 Server 端的时候，自己增加的”。该资料提高使用secret是为了充当client网站身份认证的信物。

但我不认为使用secrect就能保证这个的安全。

一般而言，HTTP上这种固定secret的方式来身份认证都是无效的，只要secret明文传播且长时间固定，那么就可以嗅探到该secret。

为了避免code被用户与攻击者同时得到，我们看攻击者可能的策略：
* 攻击者可以污染DNS，使得用户拿不到code，攻击者拿到code再配合之前嗅探到的secret，就可以自己申请token。
* 攻击者可以中间人截获然后发送给用户一个假的code

因此我认为RFC6749之所以不提及secret是以为其并不真正有效。

但我并没有找到OAuth2.0避免这个问题的方法，或者根本是我对Oauth2.0 code的使用理解有误

继续理解10.5节吧


-- 待补充

#### 没有state参数会怎么样

参考RFC6749 10.12节。

### 隐藏式授权

### 客户端凭证授权

### 其他

上面的内容主要参考：

https://www.chrisyue.com/security-issue-about-oauth-2-0-you-should-know.html

其实RFC6479第10章就是专门讲OAuth2.0的安全考虑的，更全面。

这里有个形式化分析：https://www.cnblogs.com/xinxianquan/p/10762284.html

## 主要参考

RFC6749

[资料][1]

[资料][2]


[2]:https://www.chrisyue.com/security-issue-about-oauth-2-0-you-should-know.html

[1]:https://www.yuque.com/pmiaowu/web_security_1/oauth